package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.87

import (
	"context"
	"fmt"
	"strings"
	graphql1 "tsb-service/internal/api/graphql"
	"tsb-service/internal/api/graphql/model"
	couponDomain "tsb-service/internal/modules/coupon/domain"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

// CreateCoupon is the resolver for the createCoupon field.
func (r *mutationResolver) CreateCoupon(ctx context.Context, input model.CreateCouponInput) (*model.Coupon, error) {
	discountValue, err := decimal.NewFromString(input.DiscountValue)
	if err != nil {
		return nil, fmt.Errorf("invalid discount value: %w", err)
	}

	discountType := couponDomain.DiscountType(strings.ToLower(input.DiscountType))
	if discountType != couponDomain.DiscountTypePercentage && discountType != couponDomain.DiscountTypeFixed {
		return nil, fmt.Errorf("invalid discount type: must be 'percentage' or 'fixed'")
	}

	if discountValue.LessThanOrEqual(decimal.Zero) {
		return nil, fmt.Errorf("discount value must be positive")
	}
	if discountType == couponDomain.DiscountTypePercentage && discountValue.GreaterThan(decimal.NewFromInt(100)) {
		return nil, fmt.Errorf("percentage discount cannot exceed 100")
	}

	coupon := &couponDomain.Coupon{
		ID:            uuid.New(),
		Code:          input.Code,
		DiscountType:  discountType,
		DiscountValue: discountValue,
		IsActive:      input.IsActive,
		ValidFrom:     input.ValidFrom,
		ValidUntil:    input.ValidUntil,
		MaxUses:       input.MaxUses,
	}

	if input.MinOrderAmount != nil {
		minAmount, err := decimal.NewFromString(*input.MinOrderAmount)
		if err != nil {
			return nil, fmt.Errorf("invalid min order amount: %w", err)
		}
		coupon.MinOrderAmount = &minAmount
	}

	if err := r.CouponService.CreateCoupon(ctx, coupon); err != nil {
		return nil, fmt.Errorf("failed to create coupon: %w", err)
	}

	gqlCoupon := ToGQLCoupon(coupon)
	r.Broker.Publish("couponUpdated", gqlCoupon)
	return gqlCoupon, nil
}

// UpdateCoupon is the resolver for the updateCoupon field.
func (r *mutationResolver) UpdateCoupon(ctx context.Context, id uuid.UUID, input model.UpdateCouponInput) (*model.Coupon, error) {
	coupon, err := r.CouponService.GetCoupon(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("coupon not found: %w", err)
	}

	if input.Code != nil {
		coupon.Code = *input.Code
	}
	if input.DiscountType != nil {
		dt := couponDomain.DiscountType(strings.ToLower(*input.DiscountType))
		if dt != couponDomain.DiscountTypePercentage && dt != couponDomain.DiscountTypeFixed {
			return nil, fmt.Errorf("invalid discount type: must be 'percentage' or 'fixed'")
		}
		coupon.DiscountType = dt
	}
	if input.DiscountValue != nil {
		dv, err := decimal.NewFromString(*input.DiscountValue)
		if err != nil {
			return nil, fmt.Errorf("invalid discount value: %w", err)
		}
		if dv.LessThanOrEqual(decimal.Zero) {
			return nil, fmt.Errorf("discount value must be positive")
		}
		if coupon.DiscountType == couponDomain.DiscountTypePercentage && dv.GreaterThan(decimal.NewFromInt(100)) {
			return nil, fmt.Errorf("percentage discount cannot exceed 100")
		}
		coupon.DiscountValue = dv
	}
	if input.MinOrderAmount != nil {
		minAmount, err := decimal.NewFromString(*input.MinOrderAmount)
		if err != nil {
			return nil, fmt.Errorf("invalid min order amount: %w", err)
		}
		coupon.MinOrderAmount = &minAmount
	}
	if input.MaxUses != nil {
		coupon.MaxUses = input.MaxUses
	}
	if input.IsActive != nil {
		coupon.IsActive = *input.IsActive
	}
	if input.ValidFrom != nil {
		coupon.ValidFrom = input.ValidFrom
	}
	if input.ValidUntil != nil {
		coupon.ValidUntil = input.ValidUntil
	}

	if err := r.CouponService.UpdateCoupon(ctx, coupon); err != nil {
		return nil, fmt.Errorf("failed to update coupon: %w", err)
	}

	gqlCoupon := ToGQLCoupon(coupon)
	r.Broker.Publish("couponUpdated", gqlCoupon)
	return gqlCoupon, nil
}

// ValidateCoupon is the resolver for the validateCoupon field.
func (r *queryResolver) ValidateCoupon(ctx context.Context, code string, orderAmount string) (*model.CouponValidation, error) {
	amount, err := decimal.NewFromString(orderAmount)
	if err != nil {
		return nil, fmt.Errorf("invalid order amount: %w", err)
	}

	_, discount, err := r.CouponService.ValidateCoupon(ctx, code, amount)
	if err != nil {
		errMsg := err.Error()
		return &model.CouponValidation{
			Valid:          false,
			DiscountAmount: "0",
			ErrorMessage:   &errMsg,
		}, nil
	}

	return &model.CouponValidation{
		Valid:          true,
		DiscountAmount: discount.String(),
	}, nil
}

// Coupons is the resolver for the coupons field.
func (r *queryResolver) Coupons(ctx context.Context) ([]*model.Coupon, error) {
	coupons, err := r.CouponService.GetAllCoupons(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get coupons: %w", err)
	}

	result := make([]*model.Coupon, len(coupons))
	for i, c := range coupons {
		result[i] = ToGQLCoupon(c)
	}
	return result, nil
}

// Coupon is the resolver for the coupon field.
func (r *queryResolver) Coupon(ctx context.Context, id uuid.UUID) (*model.Coupon, error) {
	coupon, err := r.CouponService.GetCoupon(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("coupon not found: %w", err)
	}
	return ToGQLCoupon(coupon), nil
}

// CouponUpdated is the resolver for the couponUpdated field.
func (r *subscriptionResolver) CouponUpdated(ctx context.Context) (<-chan *model.Coupon, error) {
	ch := make(chan *model.Coupon, 1)
	sub := r.Broker.Subscribe("couponUpdated")

	go func() {
		<-ctx.Done()
		r.Broker.Unsubscribe("couponUpdated", sub)
		close(ch)
	}()

	go func() {
		for msg := range sub {
			if c, ok := msg.(*model.Coupon); ok {
				ch <- c
			}
		}
	}()

	return ch, nil
}

// Mutation returns graphql1.MutationResolver implementation.
func (r *Resolver) Mutation() graphql1.MutationResolver { return &mutationResolver{r} }

// Subscription returns graphql1.SubscriptionResolver implementation.
func (r *Resolver) Subscription() graphql1.SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
