package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"errors"
	"fmt"
	"log"
	"strings"
	graphql1 "tsb-service/internal/api/graphql"
	"tsb-service/internal/api/graphql/model"
	productApplication "tsb-service/internal/modules/product/application"
	"tsb-service/internal/modules/product/domain"
	"tsb-service/pkg/utils"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.CreateProductInput) (*model.Product, error) {
	userLang := utils.GetLang(ctx)

	// normalize comma decimal separator
	clean := strings.ReplaceAll(strings.TrimSpace(input.Price), ",", ".")
	p, err := decimal.NewFromString(clean)
	if err != nil {
		return nil, fmt.Errorf("invalid price format: %w", err)
	}

	prod, err := r.ProductService.CreateProduct(
		ctx,
		input.CategoryID,
		p,
		input.Code,
		input.PieceCount,
		input.IsVisible,
		input.IsAvailable,
		input.IsHalal,
		input.IsVegan,
		input.IsDiscountable,
		toDomainTranslations(input.Translations),
	)

	if err != nil {
		return nil, fmt.Errorf("failed to create product: %w", err)
	}

	// 2. If an image was supplied, forward it to the file‑service
	if input.Image != nil {
		if err := utils.UploadProductImage(ctx, input.Image.File, input.Image.Filename, prod.Slug); err != nil {
			log.Printf("image upload failed: %v", err)
		}
	}

	// 3. Map domain → GraphQL and return
	gqlProd := ToGQLProduct(prod, userLang)
	return gqlProd, nil
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, id uuid.UUID, input model.UpdateProductInput) (*model.Product, error) {
	userLang := utils.GetLang(ctx)

	// 1. Load the current product so we can patch only the provided fields.
	prod, err := r.ProductService.GetProduct(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch product %s: %w", id, err)
	}

	// 2. Apply changes from the GraphQL input.
	if input.CategoryID != nil {
		prod.CategoryID = *input.CategoryID
	}

	if input.Price != nil {
		clean := strings.ReplaceAll(strings.TrimSpace(*input.Price), ",", ".")
		p, err := decimal.NewFromString(clean)
		if err != nil {
			return nil, fmt.Errorf("invalid price format: %w", err)
		}
		prod.Price = p
	}

	if input.Code != nil {
		prod.Code = input.Code
	}
	if input.PieceCount != nil {
		prod.PieceCount = input.PieceCount
	}
	if input.IsVisible != nil {
		prod.IsVisible = *input.IsVisible
	}
	if input.IsAvailable != nil {
		prod.IsAvailable = *input.IsAvailable
	}
	if input.IsHalal != nil {
		prod.IsHalal = *input.IsHalal
	}
	if input.IsVegan != nil {
		prod.IsVegan = *input.IsVegan
	}
	if input.Translations != nil {
		prod.Translations = toDomainTranslationsPtr(input.Translations)
	}

	// 3. Persist the update with the single domain object.
	if err := r.ProductService.UpdateProduct(ctx, prod); err != nil {
		return nil, fmt.Errorf("failed to update product: %w", err)
	}

	// 4. We need to refetch the product to get the latest slug
	prod, err = r.ProductService.GetProduct(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch product %s: %w", id, err)
	}

	// 5. Upload/replace image if provided.
	if input.Image != nil {
		if err := utils.UploadProductImage(
			ctx,
			input.Image.File,
			input.Image.Filename,
			prod.Slug, // slug might be nil; helper handles that
		); err != nil {
			log.Printf("image upload failed: %v", err)
		}
	}

	// 6. Return the updated product in GraphQL form.
	return ToGQLProduct(prod, userLang), nil
}

// SyncMenuWithDeliveroo is the resolver for the syncMenuWithDeliveroo field.
func (r *mutationResolver) SyncMenuWithDeliveroo(ctx context.Context) (*model.SyncMenuResult, error) {
	// Check if Deliveroo service is configured
	if r.DeliverooService == nil {
		return &model.SyncMenuResult{
			Success:         false,
			Message:         "Deliveroo service not configured. Please set DELIVEROO_CLIENT_ID, DELIVEROO_CLIENT_SECRET, DELIVEROO_BRAND_ID, and DELIVEROO_MENU_ID",
			CategoriesCount: 0,
			ProductsCount:   0,
		}, nil
	}

	// Get all categories and products
	categories, err := r.ProductService.GetCategories(ctx)
	if err != nil {
		return &model.SyncMenuResult{
			Success:         false,
			Message:         fmt.Sprintf("Failed to fetch categories: %v", err),
			CategoriesCount: 0,
			ProductsCount:   0,
		}, nil
	}

	products, err := r.ProductService.GetProducts(ctx)
	if err != nil {
		return &model.SyncMenuResult{
			Success:         false,
			Message:         fmt.Sprintf("Failed to fetch products: %v", err),
			CategoriesCount: len(categories),
			ProductsCount:   0,
		}, nil
	}

	// Run sync in background goroutine
	go func() {
		// Create a new context for the background operation
		// Use context.Background() since the original request context will be cancelled
		bgCtx := context.Background()

		log.Printf("Starting background Deliveroo menu sync (%d categories, %d products)",
			len(categories), len(products))

		if err := r.DeliverooService.SyncMenu(bgCtx, categories, products); err != nil {
			log.Printf("Deliveroo sync failed: %v", err)
		} else {
			log.Printf("Deliveroo sync completed successfully")
		}
	}()

	// Return immediate success response
	return &model.SyncMenuResult{
		Success:         true,
		Message:         "Menu sync started in background. Check server logs for completion status.",
		CategoriesCount: len(categories),
		ProductsCount:   len(products),
	}, nil
}

// Category is the resolver for the category field.
func (r *productResolver) Category(ctx context.Context, obj *model.Product) (*model.ProductCategory, error) {
	userLang := utils.GetLang(ctx)

	loader := productApplication.GetProductCategoryLoader(ctx)
	if loader == nil {
		return nil, errors.New("no product category loader found")
	}

	// Check for error while loading the category.
	c, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load product category: %w", err)
	}

	// Return nil if no categories were found.
	if len(c) == 0 {
		return nil, nil
	}

	// Map the categories to the GraphQL model
	productCategories := Map(c, func(category *domain.Category) *model.ProductCategory {
		return ToGQLProductCategory(category, userLang)
	})

	// Return the first category found. (Assuming one product belongs to one category)
	return productCategories[0], nil
}

// Translations is the resolver for the translations field.
func (r *productResolver) Translations(ctx context.Context, obj *model.Product) ([]*model.Translation, error) {
	loader := productApplication.GetProductTranslationLoader(ctx)
	if loader == nil {
		return nil, errors.New("no product translations loader found")
	}

	// Load domain.Translation slices by product ID
	pts, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load product translations: %w", err)
	}

	// Map domain.Translation → *model.Translation
	translations := Map(pts, func(t *domain.Translation) *model.Translation {
		return ToGQLTranslation(t)
	})

	// If there are no translations, return nil
	if len(translations) == 0 {
		return nil, nil
	}

	return translations, nil
}

// Products is the resolver for the products field.
func (r *productCategoryResolver) Products(ctx context.Context, obj *model.ProductCategory) ([]*model.Product, error) {
	userLang := utils.GetLang(ctx)

	loader := productApplication.GetCategoryProductLoader(ctx)

	if loader == nil {
		return nil, errors.New("no category product loader found")
	}

	// Check for error while loading the products.
	p, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load products: %w", err)
	}

	// Map the products to the GraphQL model
	products := Map(p, func(product *domain.Product) *model.Product {
		return ToGQLProduct(product, userLang)
	})

	return products, nil
}

// Translations is the resolver for the translations field.
func (r *productCategoryResolver) Translations(ctx context.Context, obj *model.ProductCategory) ([]*model.Translation, error) {
	loader := productApplication.GetCategoryTranslationLoader(ctx)

	if loader == nil {
		return nil, errors.New("no category translations loader found")
	}

	// Check for error while loading the translations.
	pc, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load category translations: %w", err)
	}

	// Map the translations to the GraphQL model
	translations := Map(pc, func(t *domain.Translation) *model.Translation {
		return ToGQLTranslation(t)
	})

	// Return nil if no translations were found.
	if len(translations) == 0 {
		return nil, nil
	}

	// Return translations found.
	return translations, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id uuid.UUID) (*model.Product, error) {
	userLang := utils.GetLang(ctx)

	p, err := r.ProductService.GetProduct(ctx, id)

	if err != nil {
		return nil, fmt.Errorf("failed to get product: %w", err)
	}

	if p == nil {
		return nil, nil
	}

	// Map the product to the GraphQL model
	product := ToGQLProduct(p, userLang)

	return product, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context) ([]*model.Product, error) {
	userLang := utils.GetLang(ctx)

	p, err := r.ProductService.GetProducts(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get products: %w", err)
	}

	products := Map(p, func(product *domain.Product) *model.Product {
		return ToGQLProduct(product, userLang)
	})

	return products, nil
}

// ProductCategory is the resolver for the productCategory field.
func (r *queryResolver) ProductCategory(ctx context.Context, id uuid.UUID) (*model.ProductCategory, error) {
	userLang := utils.GetLang(ctx)

	c, err := r.ProductService.GetCategory(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get category: %w", err)
	}

	if c == nil {
		return nil, nil
	}

	// Map the category to the GraphQL model
	category := ToGQLProductCategory(c, userLang)

	return category, nil
}

// ProductCategories is the resolver for the productCategories field.
func (r *queryResolver) ProductCategories(ctx context.Context) ([]*model.ProductCategory, error) {
	userLang := utils.GetLang(ctx)

	c, err := r.ProductService.GetCategories(ctx)

	if err != nil {
		return nil, fmt.Errorf("failed to get categories: %w", err)
	}

	categories := Map(c, func(cat *domain.Category) *model.ProductCategory {
		return ToGQLProductCategory(cat, userLang)
	})

	return categories, nil
}

// SyncEvents is the resolver for the syncEvents subscription field.
func (r *subscriptionResolver) SyncEvents(ctx context.Context) (<-chan *model.SyncEvent, error) {
	log.Println("Client subscribed to sync events")

	// Create a channel for this subscription
	events := make(chan *model.SyncEvent, 1)

	// Subscribe to the broker topic
	sub := r.Broker.Subscribe(SyncEventTopic)

	// Start a goroutine to forward events from broker to GraphQL subscription
	go func() {
		defer func() {
			close(events)
			r.Broker.Unsubscribe(SyncEventTopic, sub)
			log.Println("Client unsubscribed from sync events")
		}()

		for {
			select {
			case <-ctx.Done():
				// Client disconnected
				return
			case msg, ok := <-sub:
				if !ok {
					// Channel closed
					return
				}

				// Type assert the message to SyncEvent
				if event, ok := msg.(*model.SyncEvent); ok {
					select {
					case events <- event:
					case <-ctx.Done():
						return
					}
				}
			}
		}
	}()

	return events, nil
}

// Product returns graphql1.ProductResolver implementation.
func (r *Resolver) Product() graphql1.ProductResolver { return &productResolver{r} }

// ProductCategory returns graphql1.ProductCategoryResolver implementation.
func (r *Resolver) ProductCategory() graphql1.ProductCategoryResolver {
	return &productCategoryResolver{r}
}

type productResolver struct{ *Resolver }
type productCategoryResolver struct{ *Resolver }
