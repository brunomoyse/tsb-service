package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"strings"
	graphql1 "tsb-service/internal/api/graphql"
	"tsb-service/internal/api/graphql/model"
	productApplication "tsb-service/internal/modules/product/application"
	"tsb-service/internal/modules/product/domain"
	"tsb-service/pkg/utils"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.CreateProductInput) (*model.Product, error) {
	userLang := utils.GetLang(ctx)

	// normalize comma decimal separator
	clean := strings.ReplaceAll(strings.TrimSpace(input.Price), ",", ".")
	p, err := decimal.NewFromString(clean)
	if err != nil {
		return nil, fmt.Errorf("invalid price format: %w", err)
	}

	prod, err := r.ProductService.CreateProduct(
		ctx,
		input.CategoryID,
		p,
		input.Code,
		input.PieceCount,
		input.IsVisible,
		input.IsAvailable,
		input.IsHalal,
		input.IsVegan,
		input.IsDiscountable,
		toDomainTranslations(input.Translations),
	)

	if err != nil {
		return nil, fmt.Errorf("failed to create product: %w", err)
	}

	// 2. If an image was supplied, forward it to the file‑service
	if input.Image != nil {
		if err := utils.UploadProductImage(ctx, input.Image.File, input.Image.Filename, prod.Slug); err != nil {
			slog.ErrorContext(ctx, "image upload failed", "product_id", prod.ID, "error", err)
		}
	}

	// 3. Map domain → GraphQL and return
	gqlProd := ToGQLProduct(prod, userLang)
	return gqlProd, nil
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, id uuid.UUID, input model.UpdateProductInput) (*model.Product, error) {
	userLang := utils.GetLang(ctx)

	// 1. Load the current product so we can patch only the provided fields.
	prod, err := r.ProductService.GetProduct(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch product %s: %w", id, err)
	}

	// 2. Apply changes from the GraphQL input.
	if input.CategoryID != nil {
		prod.CategoryID = *input.CategoryID
	}

	if input.Price != nil {
		clean := strings.ReplaceAll(strings.TrimSpace(*input.Price), ",", ".")
		p, err := decimal.NewFromString(clean)
		if err != nil {
			return nil, fmt.Errorf("invalid price format: %w", err)
		}
		prod.Price = p
	}

	if input.Code != nil {
		prod.Code = input.Code
	}
	if input.PieceCount != nil {
		prod.PieceCount = input.PieceCount
	}
	if input.IsVisible != nil {
		prod.IsVisible = *input.IsVisible
	}
	if input.IsAvailable != nil {
		prod.IsAvailable = *input.IsAvailable
	}
	if input.IsHalal != nil {
		prod.IsHalal = *input.IsHalal
	}
	if input.IsVegan != nil {
		prod.IsVegan = *input.IsVegan
	}
	if input.Translations != nil {
		prod.Translations = toDomainTranslationsPtr(input.Translations)
	}

	// 3. Persist the update with the single domain object.
	if err := r.ProductService.UpdateProduct(ctx, prod); err != nil {
		return nil, fmt.Errorf("failed to update product: %w", err)
	}

	// 4. We need to refetch the product to get the latest slug
	prod, err = r.ProductService.GetProduct(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch product %s: %w", id, err)
	}

	// 5. Upload/replace image if provided.
	if input.Image != nil {
		if err := utils.UploadProductImage(
			ctx,
			input.Image.File,
			input.Image.Filename,
			prod.Slug, // slug might be nil; helper handles that
		); err != nil {
			slog.ErrorContext(ctx, "image upload failed", "product_id", id, "error", err)
		}
	}

	// 6. Return the updated product in GraphQL form.
	return ToGQLProduct(prod, userLang), nil
}

// Category is the resolver for the category field.
func (r *productResolver) Category(ctx context.Context, obj *model.Product) (*model.ProductCategory, error) {
	userLang := utils.GetLang(ctx)

	loader := productApplication.GetProductCategoryLoader(ctx)
	if loader == nil {
		return nil, errors.New("no product category loader found")
	}

	// Check for error while loading the category.
	c, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load product category: %w", err)
	}

	// Return nil if no categories were found.
	if len(c) == 0 {
		return nil, nil
	}

	// Map the categories to the GraphQL model
	productCategories := Map(c, func(category *domain.Category) *model.ProductCategory {
		return ToGQLProductCategory(category, userLang)
	})

	// Return the first category found. (Assuming one product belongs to one category)
	return productCategories[0], nil
}

// Translations is the resolver for the translations field.
func (r *productResolver) Translations(ctx context.Context, obj *model.Product) ([]*model.Translation, error) {
	loader := productApplication.GetProductTranslationLoader(ctx)
	if loader == nil {
		return nil, errors.New("no product translations loader found")
	}

	// Load domain.Translation slices by product ID
	pts, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load product translations: %w", err)
	}

	// Map domain.Translation → *model.Translation
	translations := Map(pts, func(t *domain.Translation) *model.Translation {
		return ToGQLTranslation(t)
	})

	// If there are no translations, return nil
	if len(translations) == 0 {
		return nil, nil
	}

	return translations, nil
}

// Products is the resolver for the products field.
func (r *productCategoryResolver) Products(ctx context.Context, obj *model.ProductCategory) ([]*model.Product, error) {
	userLang := utils.GetLang(ctx)

	loader := productApplication.GetCategoryProductLoader(ctx)

	if loader == nil {
		return nil, errors.New("no category product loader found")
	}

	// Check for error while loading the products.
	p, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load products: %w", err)
	}

	// Map the products to the GraphQL model
	products := Map(p, func(product *domain.Product) *model.Product {
		return ToGQLProduct(product, userLang)
	})

	return products, nil
}

// Translations is the resolver for the translations field.
func (r *productCategoryResolver) Translations(ctx context.Context, obj *model.ProductCategory) ([]*model.Translation, error) {
	loader := productApplication.GetCategoryTranslationLoader(ctx)

	if loader == nil {
		return nil, errors.New("no category translations loader found")
	}

	// Check for error while loading the translations.
	pc, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load category translations: %w", err)
	}

	// Map the translations to the GraphQL model
	translations := Map(pc, func(t *domain.Translation) *model.Translation {
		return ToGQLTranslation(t)
	})

	// Return nil if no translations were found.
	if len(translations) == 0 {
		return nil, nil
	}

	// Return translations found.
	return translations, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id uuid.UUID) (*model.Product, error) {
	userLang := utils.GetLang(ctx)

	p, err := r.ProductService.GetProduct(ctx, id)

	if err != nil {
		return nil, fmt.Errorf("failed to get product: %w", err)
	}

	if p == nil {
		return nil, nil
	}

	// Map the product to the GraphQL model
	product := ToGQLProduct(p, userLang)

	return product, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context) ([]*model.Product, error) {
	userLang := utils.GetLang(ctx)

	p, err := r.ProductService.GetProducts(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get products: %w", err)
	}

	products := Map(p, func(product *domain.Product) *model.Product {
		return ToGQLProduct(product, userLang)
	})

	return products, nil
}

// ProductCategory is the resolver for the productCategory field.
func (r *queryResolver) ProductCategory(ctx context.Context, id uuid.UUID) (*model.ProductCategory, error) {
	userLang := utils.GetLang(ctx)

	c, err := r.ProductService.GetCategory(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get category: %w", err)
	}

	if c == nil {
		return nil, nil
	}

	// Map the category to the GraphQL model
	category := ToGQLProductCategory(c, userLang)

	return category, nil
}

// ProductCategories is the resolver for the productCategories field.
func (r *queryResolver) ProductCategories(ctx context.Context) ([]*model.ProductCategory, error) {
	userLang := utils.GetLang(ctx)

	c, err := r.ProductService.GetCategories(ctx)

	if err != nil {
		return nil, fmt.Errorf("failed to get categories: %w", err)
	}

	categories := Map(c, func(cat *domain.Category) *model.ProductCategory {
		return ToGQLProductCategory(cat, userLang)
	})

	return categories, nil
}

// Product returns graphql1.ProductResolver implementation.
func (r *Resolver) Product() graphql1.ProductResolver { return &productResolver{r} }

// ProductCategory returns graphql1.ProductCategoryResolver implementation.
func (r *Resolver) ProductCategory() graphql1.ProductCategoryResolver {
	return &productCategoryResolver{r}
}

type productResolver struct{ *Resolver }
type productCategoryResolver struct{ *Resolver }
