package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.87

import (
	"context"
	"errors"
	"fmt"
	"strings"
	graphql1 "tsb-service/internal/api/graphql"
	"tsb-service/internal/api/graphql/model"
	productApplication "tsb-service/internal/modules/product/application"
	"tsb-service/internal/modules/product/domain"
	"tsb-service/pkg/logging"
	"tsb-service/pkg/utils"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
	"go.uber.org/zap"
)

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.CreateProductInput) (*model.Product, error) {
	userLang := utils.GetLang(ctx)

	// normalize comma decimal separator
	clean := strings.ReplaceAll(strings.TrimSpace(input.Price), ",", ".")
	p, err := decimal.NewFromString(clean)
	if err != nil {
		return nil, fmt.Errorf("invalid price format: %w", err)
	}

	prod, err := r.ProductService.CreateProduct(
		ctx,
		input.CategoryID,
		p,
		input.Code,
		input.PieceCount,
		input.IsVisible,
		input.IsAvailable,
		input.IsHalal,
		input.IsVegan,
		input.IsSpicy,
		input.IsDiscountable,
		toDomainTranslations(input.Translations),
	)

	if err != nil {
		return nil, fmt.Errorf("failed to create product: %w", err)
	}

	// 2. If an image was supplied, forward it to the file‑service
	if input.Image != nil {
		if err := utils.UploadProductImage(ctx, input.Image.File, input.Image.Filename, prod.Slug); err != nil {
			logging.FromContext(ctx).Error("image upload failed", zap.String("product_id", prod.ID.String()), zap.Error(err))
		}
	}

	// 3. Map domain → GraphQL and return
	gqlProd := ToGQLProduct(prod, userLang)
	return gqlProd, nil
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, id uuid.UUID, input model.UpdateProductInput) (*model.Product, error) {
	userLang := utils.GetLang(ctx)

	// 1. Load the current product so we can patch only the provided fields.
	prod, err := r.ProductService.GetProduct(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch product %s: %w", id, err)
	}

	// 2. Apply changes from the GraphQL input.
	if input.CategoryID != nil {
		prod.CategoryID = *input.CategoryID
	}

	if input.Price != nil {
		clean := strings.ReplaceAll(strings.TrimSpace(*input.Price), ",", ".")
		p, err := decimal.NewFromString(clean)
		if err != nil {
			return nil, fmt.Errorf("invalid price format: %w", err)
		}
		prod.Price = p
	}

	if input.Code != nil {
		prod.Code = input.Code
	}
	if input.PieceCount != nil {
		prod.PieceCount = input.PieceCount
	}
	if input.IsVisible != nil {
		prod.IsVisible = *input.IsVisible
	}
	if input.IsAvailable != nil {
		prod.IsAvailable = *input.IsAvailable
	}
	if input.IsHalal != nil {
		prod.IsHalal = *input.IsHalal
	}
	if input.IsVegan != nil {
		prod.IsVegan = *input.IsVegan
	}
	if input.IsSpicy != nil {
		prod.IsSpicy = *input.IsSpicy
	}
	if input.Translations != nil {
		prod.Translations = toDomainTranslationsPtr(input.Translations)
	}

	// 3. Save the old slug before persisting the update.
	oldSlug := ""
	if prod.Slug != nil {
		oldSlug = *prod.Slug
	}

	// 4. Persist the update with the single domain object.
	if err := r.ProductService.UpdateProduct(ctx, prod); err != nil {
		return nil, fmt.Errorf("failed to update product: %w", err)
	}

	// 5. We need to refetch the product to get the latest slug
	prod, err = r.ProductService.GetProduct(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch product %s: %w", id, err)
	}

	newSlug := ""
	if prod.Slug != nil {
		newSlug = *prod.Slug
	}

	// 6. Upload/replace image if provided.
	if input.Image != nil {
		if err := utils.UploadProductImage(
			ctx,
			input.Image.File,
			input.Image.Filename,
			prod.Slug, // slug might be nil; helper handles that
		); err != nil {
			logging.FromContext(ctx).Error("image upload failed", zap.String("product_id", id.String()), zap.Error(err))
		}
		// If slug changed and new image was uploaded, clean up old image
		if oldSlug != "" && oldSlug != newSlug {
			go func() {
				if err := utils.DeleteProductImage(ctx, oldSlug); err != nil {
					logging.FromContext(ctx).Error("failed to delete old product image", zap.String("old_slug", oldSlug), zap.Error(err))
				}
			}()
		}
	} else if oldSlug != "" && newSlug != "" && oldSlug != newSlug {
		// 7. No new image, but slug changed — rename the existing image.
		go func() {
			if err := utils.RenameProductImage(ctx, oldSlug, newSlug); err != nil {
				logging.FromContext(ctx).Error("failed to rename product image", zap.String("old_slug", oldSlug), zap.String("new_slug", newSlug), zap.Error(err))
			}
		}()
	}

	// 8. Notify subscribers of product update.
	gqlProd := ToGQLProduct(prod, userLang)
	r.Broker.Publish("productUpdated", gqlProd)

	return gqlProd, nil
}

// CreateProductChoice is the resolver for the createProductChoice field.
func (r *mutationResolver) CreateProductChoice(ctx context.Context, input model.CreateProductChoiceInput) (*model.ProductChoice, error) {
	userLang := utils.GetLang(ctx)

	clean := strings.ReplaceAll(strings.TrimSpace(input.PriceModifier), ",", ".")
	priceMod, err := decimal.NewFromString(clean)
	if err != nil {
		return nil, fmt.Errorf("invalid price modifier format: %w", err)
	}

	translations := make([]domain.ChoiceTranslation, len(input.Translations))
	for i, t := range input.Translations {
		translations[i] = domain.ChoiceTranslation{
			Locale: t.Locale,
			Name:   t.Name,
		}
	}

	choice := &domain.ProductChoice{
		ID:            uuid.New(),
		ProductID:     input.ProductID,
		PriceModifier: priceMod,
		SortOrder:     input.SortOrder,
		Translations:  translations,
	}

	if err := r.ProductService.CreateChoice(ctx, choice); err != nil {
		return nil, fmt.Errorf("failed to create product choice: %w", err)
	}

	return ToGQLProductChoice(choice, userLang), nil
}

// UpdateProductChoice is the resolver for the updateProductChoice field.
func (r *mutationResolver) UpdateProductChoice(ctx context.Context, id uuid.UUID, input model.UpdateProductChoiceInput) (*model.ProductChoice, error) {
	userLang := utils.GetLang(ctx)

	choice, err := r.ProductService.GetChoiceByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch product choice: %w", err)
	}

	if input.PriceModifier != nil {
		clean := strings.ReplaceAll(strings.TrimSpace(*input.PriceModifier), ",", ".")
		priceMod, err := decimal.NewFromString(clean)
		if err != nil {
			return nil, fmt.Errorf("invalid price modifier format: %w", err)
		}
		choice.PriceModifier = priceMod
	}
	if input.SortOrder != nil {
		choice.SortOrder = *input.SortOrder
	}
	if input.Translations != nil {
		translations := make([]domain.ChoiceTranslation, len(input.Translations))
		for i, t := range input.Translations {
			translations[i] = domain.ChoiceTranslation{
				ProductChoiceID: id,
				Locale:          t.Locale,
				Name:            t.Name,
			}
		}
		choice.Translations = translations
	}

	if err := r.ProductService.UpdateChoice(ctx, choice); err != nil {
		return nil, fmt.Errorf("failed to update product choice: %w", err)
	}

	return ToGQLProductChoice(choice, userLang), nil
}

// DeleteProductChoice is the resolver for the deleteProductChoice field.
func (r *mutationResolver) DeleteProductChoice(ctx context.Context, id uuid.UUID) (bool, error) {
	if err := r.ProductService.DeleteChoice(ctx, id); err != nil {
		return false, fmt.Errorf("failed to delete product choice: %w", err)
	}
	return true, nil
}

// Category is the resolver for the category field.
func (r *productResolver) Category(ctx context.Context, obj *model.Product) (*model.ProductCategory, error) {
	userLang := utils.GetLang(ctx)

	loader := productApplication.GetProductCategoryLoader(ctx)
	if loader == nil {
		return nil, errors.New("no product category loader found")
	}

	// Check for error while loading the category.
	c, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load product category: %w", err)
	}

	// Return nil if no categories were found.
	if len(c) == 0 {
		return nil, nil
	}

	// Map the categories to the GraphQL model
	productCategories := Map(c, func(category *domain.Category) *model.ProductCategory {
		return ToGQLProductCategory(category, userLang)
	})

	// Return the first category found. (Assuming one product belongs to one category)
	return productCategories[0], nil
}

// Choices is the resolver for the choices field.
func (r *productResolver) Choices(ctx context.Context, obj *model.Product) ([]*model.ProductChoice, error) {
	userLang := utils.GetLang(ctx)

	loader := productApplication.GetProductChoiceLoader(ctx)
	if loader == nil {
		return nil, errors.New("no product choice loader found")
	}

	choices, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load product choices: %w", err)
	}

	return Map(choices, func(c *domain.ProductChoice) *model.ProductChoice {
		return ToGQLProductChoice(c, userLang)
	}), nil
}

// Translations is the resolver for the translations field.
func (r *productResolver) Translations(ctx context.Context, obj *model.Product) ([]*model.Translation, error) {
	loader := productApplication.GetProductTranslationLoader(ctx)
	if loader == nil {
		return nil, errors.New("no product translations loader found")
	}

	// Load domain.Translation slices by product ID
	pts, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load product translations: %w", err)
	}

	// Map domain.Translation → *model.Translation
	translations := Map(pts, func(t *domain.Translation) *model.Translation {
		return ToGQLTranslation(t)
	})

	// If there are no translations, return nil
	if len(translations) == 0 {
		return nil, nil
	}

	return translations, nil
}

// Products is the resolver for the products field.
func (r *productCategoryResolver) Products(ctx context.Context, obj *model.ProductCategory) ([]*model.Product, error) {
	userLang := utils.GetLang(ctx)

	loader := productApplication.GetCategoryProductLoader(ctx)

	if loader == nil {
		return nil, errors.New("no category product loader found")
	}

	// Check for error while loading the products.
	p, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load products: %w", err)
	}

	// Map the products to the GraphQL model
	products := Map(p, func(product *domain.Product) *model.Product {
		return ToGQLProduct(product, userLang)
	})

	return products, nil
}

// Translations is the resolver for the translations field.
func (r *productCategoryResolver) Translations(ctx context.Context, obj *model.ProductCategory) ([]*model.Translation, error) {
	loader := productApplication.GetCategoryTranslationLoader(ctx)

	if loader == nil {
		return nil, errors.New("no category translations loader found")
	}

	// Check for error while loading the translations.
	pc, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load category translations: %w", err)
	}

	// Map the translations to the GraphQL model
	translations := Map(pc, func(t *domain.Translation) *model.Translation {
		return ToGQLTranslation(t)
	})

	// Return nil if no translations were found.
	if len(translations) == 0 {
		return nil, nil
	}

	// Return translations found.
	return translations, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id uuid.UUID) (*model.Product, error) {
	userLang := utils.GetLang(ctx)

	p, err := r.ProductService.GetProduct(ctx, id)

	if err != nil {
		return nil, fmt.Errorf("failed to get product: %w", err)
	}

	if p == nil {
		return nil, nil
	}

	// Map the product to the GraphQL model
	product := ToGQLProduct(p, userLang)

	return product, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context) ([]*model.Product, error) {
	userLang := utils.GetLang(ctx)

	p, err := r.ProductService.GetProducts(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get products: %w", err)
	}

	products := Map(p, func(product *domain.Product) *model.Product {
		return ToGQLProduct(product, userLang)
	})

	return products, nil
}

// ProductCategory is the resolver for the productCategory field.
func (r *queryResolver) ProductCategory(ctx context.Context, id uuid.UUID) (*model.ProductCategory, error) {
	userLang := utils.GetLang(ctx)

	c, err := r.ProductService.GetCategory(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get category: %w", err)
	}

	if c == nil {
		return nil, nil
	}

	// Map the category to the GraphQL model
	category := ToGQLProductCategory(c, userLang)

	return category, nil
}

// ProductCategories is the resolver for the productCategories field.
func (r *queryResolver) ProductCategories(ctx context.Context) ([]*model.ProductCategory, error) {
	userLang := utils.GetLang(ctx)

	c, err := r.ProductService.GetCategories(ctx)

	if err != nil {
		return nil, fmt.Errorf("failed to get categories: %w", err)
	}

	categories := Map(c, func(cat *domain.Category) *model.ProductCategory {
		return ToGQLProductCategory(cat, userLang)
	})

	return categories, nil
}

// ProductUpdated is the resolver for the productUpdated field.
func (r *subscriptionResolver) ProductUpdated(ctx context.Context) (<-chan *model.Product, error) {
	ch := make(chan *model.Product, 1)
	sub := r.Broker.Subscribe("productUpdated")

	go func() {
		<-ctx.Done()
		r.Broker.Unsubscribe("productUpdated", sub)
		close(ch)
	}()

	go func() {
		for msg := range sub {
			if p, ok := msg.(*model.Product); ok {
				ch <- p
			}
		}
	}()

	return ch, nil
}

// Product returns graphql1.ProductResolver implementation.
func (r *Resolver) Product() graphql1.ProductResolver { return &productResolver{r} }

// ProductCategory returns graphql1.ProductCategoryResolver implementation.
func (r *Resolver) ProductCategory() graphql1.ProductCategoryResolver {
	return &productCategoryResolver{r}
}

type productResolver struct{ *Resolver }
type productCategoryResolver struct{ *Resolver }
