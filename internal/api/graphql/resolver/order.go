package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"fmt"
	graphql1 "tsb-service/internal/api/graphql"
	"tsb-service/internal/api/graphql/model"
	addressApplication "tsb-service/internal/modules/address/application"
	addressDomain "tsb-service/internal/modules/address/domain"
	orderApplication "tsb-service/internal/modules/order/application"
	orderDomain "tsb-service/internal/modules/order/domain"
	paymentApplication "tsb-service/internal/modules/payment/application"
	paymentDomain "tsb-service/internal/modules/payment/domain"
	productApplication "tsb-service/internal/modules/product/application"
	productDomain "tsb-service/internal/modules/product/domain"
	userApplication "tsb-service/internal/modules/user/application"
	userDomain "tsb-service/internal/modules/user/domain"
	"tsb-service/pkg/utils"

	"github.com/google/uuid"
)

// UpdateOrder is the resolver for the updateOrder field.
func (r *mutationResolver) UpdateOrder(ctx context.Context, id uuid.UUID, input model.UpdateOrderInput) (*model.Order, error) {
	err := r.OrderService.UpdateOrderStatus(ctx, id, *input.Status)
	if err != nil {
		return nil, fmt.Errorf("failed to update order status: %w", err)
	}

	// Fetch the updated order
	o, _, err := r.OrderService.GetOrderByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get order: %w", err)
	}

	// Map the order to the GraphQL model
	order := ToGQLOrder(o)

	// Publish the order update to the broker
	r.Broker.Publish("ordersUpdated", order)
	r.Broker.Publish(fmt.Sprintf("orderUpdated:%s", id), order)

	return order, nil
}

// Address is the resolver for the address field.
func (r *orderResolver) Address(ctx context.Context, obj *model.Order) (*model.Address, error) {
	loader := addressApplication.GetOrderAddressLoader(ctx)

	if loader == nil {
		return nil, fmt.Errorf("no order address loader found")
	}

	// Check for error while loading the address.
	a, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load order address: %w", err)
	}

	// Map the address to the GraphQL model
	addresses := Map(a, func(address *addressDomain.Address) *model.Address {
		return ToGQLAddress(address)
	})

	// Return nil if no addresses were found.
	if len(addresses) == 0 {
		return nil, nil
	}

	// Return the first address found. (Assuming one order belongs to one address)
	return addresses[0], nil
}

// Customer is the resolver for the customer field.
func (r *orderResolver) Customer(ctx context.Context, obj *model.Order) (*model.User, error) {
	loader := userApplication.GetOrderUserLoader(ctx)

	if loader == nil {
		return nil, fmt.Errorf("no order user loader found")
	}

	// Check for error while loading the user.
	a, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load order user: %w", err)
	}

	// Map the user to the GraphQL model
	users := Map(a, func(user *userDomain.User) *model.User {
		return ToGQLUser(user)
	})

	// Return nil if no users were found.
	if len(users) == 0 {
		return nil, nil
	}

	// Return the first user found. (Assuming one order belongs to one user)
	return users[0], nil
}

// Payment is the resolver for the payment field.
func (r *orderResolver) Payment(ctx context.Context, obj *model.Order) (*model.Payment, error) {
	loader := paymentApplication.GetOrderPaymentLoader(ctx)

	if loader == nil {
		return nil, fmt.Errorf("no order payment loader found")
	}

	// Check for error while loading the payment.
	p, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load order payment: %w", err)
	}

	// Map the payment to the GraphQL model
	payments := Map(p, func(payment *paymentDomain.MolliePayment) *model.Payment {
		return ToGQLPayment(payment)
	})

	// Return nil if no payments were found.
	if len(payments) == 0 {
		return nil, nil
	}

	// Return the first payment found. (Assuming one order belongs to one payment)
	return payments[0], nil
}

// Items is the resolver for the items field.
func (r *orderResolver) Items(ctx context.Context, obj *model.Order) ([]*model.OrderItem, error) {
	loader := orderApplication.GetOrderItemLoader(ctx)

	if loader == nil {
		return nil, fmt.Errorf("no order items loader found")
	}

	// Check for error while loading the items.
	i, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load order items: %w", err)
	}

	// Map the items to the GraphQL model
	items := Map(i, func(item *orderDomain.OrderProductRaw) *model.OrderItem {
		return ToGQLOrderItem(item)
	})

	return items, nil
}

// Product is the resolver for the product field.
func (r *orderItemResolver) Product(ctx context.Context, obj *model.OrderItem) (*model.Product, error) {
	userLang := utils.GetLang(ctx)
	productID := obj.ProductID

	loader := productApplication.GetOrderItemProductLoader(ctx)

	if loader == nil {
		return nil, fmt.Errorf("no order item product loader found")
	}

	// Check for error while loading the product.
	p, err := loader.Loader.Load(ctx, productID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load order item product: %w", err)
	}

	// Map the product to the GraphQL model
	products := Map(p, func(product *productDomain.Product) *model.Product {
		return ToGQLProduct(product, userLang)
	})

	// Return nil if no products were found.
	if len(products) == 0 {
		return nil, nil
	}

	// Return the first product found. (Assuming one order item belongs to one product)
	return products[0], nil
}

// Orders is the resolver for the orders field.
func (r *queryResolver) Orders(ctx context.Context) ([]*model.Order, error) {
	o, err := r.OrderService.GetPaginatedOrders(ctx, 1, 20, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to get orders: %w", err)
	}

	orders := Map(o, func(order *orderDomain.Order) *model.Order {
		return ToGQLOrder(order)
	})

	return orders, nil
}

// Order is the resolver for the order field.
func (r *queryResolver) Order(ctx context.Context, id uuid.UUID) (*model.Order, error) {
	o, _, err := r.OrderService.GetOrderByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get order: %w", err)
	}

	if o == nil {
		return nil, nil
	}

	// Map the order to the GraphQL model
	order := ToGQLOrder(o)

	return order, nil
}

// MyOrders is the resolver for the myOrders field.
func (r *queryResolver) MyOrders(ctx context.Context) ([]*model.Order, error) {
	userID := utils.GetUserID(ctx)

	// Cast userID to uuid.UUID
	userUUID, err := uuid.Parse(userID)

	o, err := r.OrderService.GetPaginatedOrders(ctx, 1, 20, &userUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to get orders: %w", err)
	}

	orders := Map(o, func(order *orderDomain.Order) *model.Order {
		return ToGQLOrder(order)
	})

	return orders, nil
}

// MyOrder is the resolver for the myOrder field.
func (r *queryResolver) MyOrder(ctx context.Context, id uuid.UUID) (*model.Order, error) {
	// @TODO: Check if the user is the owner of the order in the service layer.
	o, _, err := r.OrderService.GetOrderByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get order: %w", err)
	}

	if o == nil {
		return nil, nil
	}

	// Map the order to the GraphQL model
	order := ToGQLOrder(o)

	return order, nil
}

// OrdersUpdated is the resolver for the ordersUpdated field.
func (r *subscriptionResolver) OrdersUpdated(ctx context.Context) (<-chan *model.Order, error) {
	ch := make(chan *model.Order, 1)
	sub := r.Broker.Subscribe("ordersUpdated")

	go func() {
		<-ctx.Done()
		r.Broker.Unsubscribe("ordersUpdated", sub)
	}()

	go func() {
		for msg := range sub {
			if o, ok := msg.(*model.Order); ok {
				ch <- o
			}
		}
	}()

	return ch, nil
}

// MyOrderUpdated is the resolver for the myOrderUpdated field.
func (r *subscriptionResolver) MyOrderUpdated(ctx context.Context, orderID uuid.UUID) (<-chan *model.Order, error) {
	userID := utils.GetUserID(ctx)
	if userID == "" {
		return nil, fmt.Errorf("UNAUTHENTICATED")
	}
	// @todo: verify the order belongs to this user
	// e.g. if !r.OrderService.BelongsTo(ctx, userID, orderID) { error }

	topic := fmt.Sprintf("orderUpdated:%s", orderID)
	ch := make(chan *model.Order, 1)
	sub := r.Broker.Subscribe(topic)

	go func() {
		<-ctx.Done()
		r.Broker.Unsubscribe(topic, sub)
	}()

	go func() {
		for msg := range sub {
			if o, ok := msg.(*model.Order); ok {
				ch <- o
			}
		}
	}()

	return ch, nil
}

// Mutation returns graphql1.MutationResolver implementation.
func (r *Resolver) Mutation() graphql1.MutationResolver { return &mutationResolver{r} }

// Order returns graphql1.OrderResolver implementation.
func (r *Resolver) Order() graphql1.OrderResolver { return &orderResolver{r} }

// OrderItem returns graphql1.OrderItemResolver implementation.
func (r *Resolver) OrderItem() graphql1.OrderItemResolver { return &orderItemResolver{r} }

// Subscription returns graphql1.SubscriptionResolver implementation.
func (r *Resolver) Subscription() graphql1.SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type orderResolver struct{ *Resolver }
type orderItemResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
