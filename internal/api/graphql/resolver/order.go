package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.87

import (
	"context"
	"fmt"
	"strings"
	graphql1 "tsb-service/internal/api/graphql"
	"tsb-service/internal/api/graphql/model"
	addressApplication "tsb-service/internal/modules/address/application"
	addressDomain "tsb-service/internal/modules/address/domain"
	orderApplication "tsb-service/internal/modules/order/application"
	orderDomain "tsb-service/internal/modules/order/domain"
	paymentApplication "tsb-service/internal/modules/payment/application"
	paymentDomain "tsb-service/internal/modules/payment/domain"
	productApplication "tsb-service/internal/modules/product/application"
	productDomain "tsb-service/internal/modules/product/domain"
	userApplication "tsb-service/internal/modules/user/application"
	userDomain "tsb-service/internal/modules/user/domain"
	"tsb-service/pkg/utils"
	es "tsb-service/pkg/email/scaleway"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
	"go.uber.org/zap"
)

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input model.CreateOrderInput) (*model.Order, error) {
	// 0) Check if ordering is allowed
	allowed, err := r.RestaurantService.IsOrderingAllowed(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to check ordering availability: %w", err)
	}
	if !allowed {
		return nil, fmt.Errorf("ordering is currently unavailable")
	}

	// 1) Authenticated user
	userID := utils.GetUserID(ctx)
	if userID == "" {
		return nil, fmt.Errorf("UNAUTHENTICATED: please login")
	}
	userUUID, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// 2) Fetch products and build price map
	prodCount := len(input.Items)
	if prodCount == 0 {
		return nil, fmt.Errorf("order must contain at least one item")
	}
	if prodCount > 50 {
		return nil, fmt.Errorf("order cannot contain more than 50 different items")
	}
	ids := make([]string, prodCount)
	for i, op := range input.Items {
		ids[i] = op.ProductID.String()
	}
	products, err := r.ProductService.GetProductsByIDs(ctx, ids)
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve products: %w", err)
	}
	priceMap := make(map[uuid.UUID]decimal.Decimal, len(products))
	for _, p := range products {
		priceMap[p.ID] = p.Price
	}

	// 3) Compute line totals and overall total
	rawItems := make([]orderDomain.OrderProductRaw, 0, prodCount)
	total := decimal.Zero
	for _, op := range input.Items {
		pid := op.ProductID
		unitPrice, ok := priceMap[pid]
		if !ok {
			return nil, fmt.Errorf("product %s not found", pid)
		}
		qty := int64(op.Quantity)
		if qty <= 0 || qty > 99 {
			return nil, fmt.Errorf("invalid quantity for product %s: must be between 1 and 99", pid)
		}

		var choiceID *uuid.UUID
		if op.ChoiceID != nil {
			choice, err := r.ProductService.GetChoiceByID(ctx, *op.ChoiceID)
			if err != nil {
				return nil, fmt.Errorf("failed to retrieve choice %s: %w", op.ChoiceID, err)
			}
			if choice == nil {
				return nil, fmt.Errorf("choice %s not found", op.ChoiceID)
			}
			if choice.ProductID != pid {
				return nil, fmt.Errorf("choice %s does not belong to product %s", op.ChoiceID, pid)
			}
			unitPrice = unitPrice.Add(choice.PriceModifier)
			choiceID = op.ChoiceID
		}

		lineTotal := unitPrice.Mul(decimal.NewFromInt(qty))
		total = total.Add(lineTotal)
		rawItems = append(rawItems, orderDomain.OrderProductRaw{
			ProductID:       pid,
			Quantity:        qty,
			UnitPrice:       unitPrice,
			TotalPrice:      lineTotal,
			ProductChoiceID: choiceID,
		})
	}

	// 4) Determine order type
	var odType orderDomain.OrderType
	switch input.OrderType {
	case model.OrderTypeEnumDelivery:
		odType = orderDomain.OrderTypeDelivery
	default:
		odType = orderDomain.OrderTypePickUp
	}

	// 5) Enforce minimum amounts
	if odType == orderDomain.OrderTypePickUp && total.LessThan(decimal.NewFromInt(20)) {
		return nil, fmt.Errorf("minimum order amount for pickup is 20")
	}
	if odType == orderDomain.OrderTypeDelivery && total.LessThan(decimal.NewFromInt(25)) {
		return nil, fmt.Errorf("minimum order amount for delivery is 25")
	}

	// 6) Compute delivery fee if needed
	fee := decimal.NewFromInt(0)
	if odType == orderDomain.OrderTypeDelivery {
		if input.AddressID == nil {
			return nil, fmt.Errorf("addressID required for delivery")
		}

		addr, err := r.AddressService.GetAddressByID(ctx, *input.AddressID)
		if err != nil {
			return nil, fmt.Errorf("failed to retrieve address: %w", err)
		}
		if addr == nil {
			return nil, fmt.Errorf("address not found")
		}
		if addr.Distance >= 9000 {
			return nil, fmt.Errorf("address too far for delivery")
		}

		var dFee int64
		switch {
		case addr.Distance < 4000:
			dFee = 0
		case addr.Distance < 5000:
			dFee = 1
		case addr.Distance < 6000:
			dFee = 2
		case addr.Distance < 7000:
			dFee = 3
		case addr.Distance < 8000:
			dFee = 4
		case addr.Distance < 9000:
			dFee = 5
		default:
			dFee = 10
		}
		fee = decimal.NewFromInt(dFee)
		total = total.Add(fee)
	}

	// Compute takeaway discount for PICKUP orders
	takeawayDiscount := decimal.Zero
	if odType == orderDomain.OrderTypePickUp {
		for _, p := range products {
			if p.IsDiscountable {
				// 10% discount on discountable items
				takeawayDiscount = takeawayDiscount.Add(p.Price.Mul(decimal.NewFromFloat(0.10)))
			}
		}
	}

	// Validate and apply coupon discount (stacks with pickup discount)
	couponDiscount := decimal.Zero
	var couponCode *string
	var validatedCouponID *uuid.UUID
	if input.CouponCode != nil && *input.CouponCode != "" {
		coupon, cd, err := r.CouponService.ValidateCoupon(ctx, *input.CouponCode, total)
		if err != nil {
			return nil, fmt.Errorf("invalid coupon: %w", err)
		}
		couponDiscount = cd
		couponCode = input.CouponCode
		validatedCouponID = &coupon.ID
	}

	// Ensure combined discounts never exceed the order total
	totalDiscount := takeawayDiscount.Add(couponDiscount)
	if totalDiscount.GreaterThan(total) {
		// Scale both proportionally
		ratio := total.Div(totalDiscount)
		takeawayDiscount = takeawayDiscount.Mul(ratio).Round(2)
		couponDiscount = total.Sub(takeawayDiscount)
	}

	var extras []orderDomain.OrderExtra
	if input.OrderExtra != nil {
		extras = make([]orderDomain.OrderExtra, len(input.OrderExtra))
		for i, extraIn := range input.OrderExtra {
			extras[i] = orderDomain.OrderExtra{
				Name:    extraIn.Name,
				Options: extraIn.Options,
			}
		}
	}

	// Capture the customer's language at order creation time
	orderLang := utils.GetLang(ctx)

	tempOrder := orderDomain.NewOrder(
		userUUID,
		odType,
		input.IsOnlinePayment,
		input.AddressID,
		input.AddressExtra,
		input.OrderNote,
		input.PreferredReadyTime,
		extras,
		&fee,
		takeawayDiscount,
		couponDiscount,
		orderLang,
	)
	tempOrder.CouponCode = couponCode

	// Atomically reserve coupon usage BEFORE creating the order to prevent race conditions
	if validatedCouponID != nil {
		ok, err := r.CouponService.IncrementUsageAtomic(ctx, *validatedCouponID)
		if err != nil {
			return nil, fmt.Errorf("failed to reserve coupon: %w", err)
		}
		if !ok {
			return nil, fmt.Errorf("coupon is no longer valid or usage limit reached")
		}
	}

	// 8) Persist via service
	order, itemsRaw, err := r.OrderService.CreateOrder(ctx, tempOrder, &rawItems)
	if err != nil {
		return nil, fmt.Errorf("failed to create order: %w", err)
	}

	// 9) Enrich each raw item with its product details
	//    build a lookup map from product ID → product info
	prodMap := make(map[uuid.UUID]productDomain.ProductOrderDetails, len(products))
	for _, p := range products {
		prodMap[p.ID] = *p
	}

	// now map persisted raw items → full OrderProduct
	items := make([]orderDomain.OrderProduct, len(*itemsRaw))
	for i, ir := range *itemsRaw {
		pd, ok := prodMap[ir.ProductID]
		if !ok {
			// this should never happen—just in case
			return nil, fmt.Errorf("missing product details for %s", ir.ProductID)
		}
		items[i] = orderDomain.OrderProduct{
			Product: orderDomain.Product{
				ID:           pd.ID,
				Code:         pd.Code,
				CategoryName: pd.CategoryName,
				Name:         pd.Name,
			},
			Quantity:   ir.Quantity,
			UnitPrice:  ir.UnitPrice,
			TotalPrice: ir.TotalPrice,
		}
	}

	user, err := r.UserService.GetUserByID(ctx, order.UserID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve user: %w", err)
	}

	// Handle payment creation if needed.
	if input.IsOnlinePayment {
		address := &addressDomain.Address{}
		if odType == orderDomain.OrderTypeDelivery {
			if input.AddressID == nil {
				return nil, fmt.Errorf("addressID required for delivery")
			}

			address, err = r.AddressService.GetAddressByID(ctx, *input.AddressID)
			if err != nil {
				return nil, fmt.Errorf("failed to retrieve address: %w", err)
			}
		}
		molliePayment, err := r.PaymentService.CreatePayment(ctx, *order, items, *user, address)
		if err != nil || molliePayment == nil {
			return nil, fmt.Errorf("failed to create payment: %w", err)
		}
	} else {
		// If offline payment, send the notification e-mail already
		go func() {
			err = es.SendOrderPendingEmail(*user, order.Language, *order, items)
			if err != nil {
				zap.L().Error("failed to send order pending email", zap.String("order_id", order.ID.String()), zap.Error(err))
			}
		}()
	}

	// 10) Map to GraphQL model
	gql := ToGQLOrder(order)

	// 11) Publish subscription
	r.Broker.Publish("orderCreated", gql)

	return gql, nil
}

// UpdateOrder is the resolver for the updateOrder field.
func (r *mutationResolver) UpdateOrder(ctx context.Context, id uuid.UUID, input model.UpdateOrderInput) (*model.Order, error) {
	oldOrder, _, err := r.OrderService.GetOrderByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get order: %w", err)
	}

	err = r.OrderService.UpdateOrder(ctx, id, input.Status, input.EstimatedReadyTime)
	if err != nil {
		return nil, fmt.Errorf("failed to update order status: %w", err)
	}

	// Fetch the updated order
	o, opRaw, err := r.OrderService.GetOrderByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get order: %w", err)
	}

	// Use the stored order language for all emails (captured at order creation)
	lang := o.Language

	// If new status is "CONFIRMED" or "PREPARING", send the confirmation email
	if oldOrder.OrderStatus == orderDomain.OrderStatusPending && (o.OrderStatus == orderDomain.OrderStatusConfirmed || o.OrderStatus == orderDomain.OrderStatusPreparing) {
		go func() {
			user, err := r.UserService.GetUserByID(context.Background(), o.UserID.String())
			if err != nil {
				zap.L().Error("failed to retrieve user", zap.String("order_id", o.ID.String()), zap.Error(err))
				return
			}

			// 1) collect product IDs as strings
			raws := *opRaw
			ids := make([]string, len(raws))
			for i, ir := range raws {
				ids[i] = ir.ProductID.String()
			}

			// 2) fetch all products in one go
			prodDetailsSlice, err := r.ProductService.GetProductsByIDs(context.Background(), ids)
			if err != nil {
				zap.L().Error("failed to retrieve products", zap.String("order_id", o.ID.String()), zap.Error(err))
				return
			}

			// 3) build a map for quick lookup
			prodMap := make(map[uuid.UUID]productDomain.ProductOrderDetails, len(prodDetailsSlice))
			for _, pd := range prodDetailsSlice {
				prodMap[pd.ID] = *pd
			}

			// 4) enrich raws into your final items
			items := make([]orderDomain.OrderProduct, len(raws))
			for i, ir := range raws {
				pd, ok := prodMap[ir.ProductID]
				if !ok {
					zap.L().Error("missing product details", zap.String("order_id", o.ID.String()), zap.String("product_id", ir.ProductID.String()))
					return
				}
				items[i] = orderDomain.OrderProduct{
					Product: orderDomain.Product{
						ID:           pd.ID,
						Code:         pd.Code,
						CategoryName: pd.CategoryName,
						Name:         pd.Name,
					},
					Quantity:   ir.Quantity,
					UnitPrice:  ir.UnitPrice,
					TotalPrice: ir.TotalPrice,
				}
			}

			var address *addressDomain.Address
			if o.AddressID != nil {
				address, err = r.AddressService.GetAddressByID(context.Background(), *o.AddressID)
				if err != nil {
					zap.L().Error("failed to retrieve address", zap.String("order_id", o.ID.String()), zap.Error(err))
					return
				}
			}

			err = es.SendOrderConfirmedEmail(*user, lang, *o, items, address)
			if err != nil {
				zap.L().Error("failed to send order confirmed email", zap.String("order_id", o.ID.String()), zap.Error(err))
			}
		}()
	}

	// If new status is "AWAITING_PICK_UP" or "OUT_FOR_DELIVERY", send the order ready email
	if o.OrderStatus == orderDomain.OrderStatusAwaitingUp || o.OrderStatus == orderDomain.OrderStatusOutForDelivery {
		go func() {
			user, err := r.UserService.GetUserByID(context.Background(), o.UserID.String())
			if err != nil {
				zap.L().Error("failed to retrieve user", zap.String("order_id", o.ID.String()), zap.Error(err))
				return
			}

			err = es.SendOrderReadyEmail(*user, lang, *o)
			if err != nil {
				zap.L().Error("failed to send order ready email", zap.String("order_id", o.ID.String()), zap.Error(err))
			}
		}()
	}

	// If new status is "PICKED_UP" or "DELIVERED", send the order completed email
	if o.OrderStatus == orderDomain.OrderStatusPickedUp || o.OrderStatus == orderDomain.OrderStatusDelivered {
		go func() {
			user, err := r.UserService.GetUserByID(context.Background(), o.UserID.String())
			if err != nil {
				zap.L().Error("failed to retrieve user", zap.String("order_id", o.ID.String()), zap.Error(err))
				return
			}

			err = es.SendOrderCompletedEmail(*user, lang)
			if err != nil {
				zap.L().Error("failed to send order completed email", zap.String("order_id", o.ID.String()), zap.Error(err))
			}
		}()
	}

	// If estimated ready time changed on an already-confirmed order (not the initial confirmation)
	isInitialConfirmation := oldOrder.OrderStatus == orderDomain.OrderStatusPending &&
		(o.OrderStatus == orderDomain.OrderStatusConfirmed || o.OrderStatus == orderDomain.OrderStatusPreparing)
	if input.EstimatedReadyTime != nil && oldOrder.EstimatedReadyTime != nil && !isInitialConfirmation {
		go func() {
			user, err := r.UserService.GetUserByID(context.Background(), o.UserID.String())
			if err != nil {
				zap.L().Error("failed to retrieve user", zap.String("order_id", o.ID.String()), zap.Error(err))
				return
			}

			err = es.SendReadyTimeUpdatedEmail(*user, lang, *o)
			if err != nil {
				zap.L().Error("failed to send ready time updated email", zap.String("order_id", o.ID.String()), zap.Error(err))
			}
		}()
	}

	// If new status is "CANCELED", refund & send the cancellation email
	if o.OrderStatus == orderDomain.OrderStatusCanceled {
		payment, err := r.PaymentService.GetPaymentByOrderID(ctx, o.ID)
		if err == nil && payment != nil {
			refund, refundErr := r.PaymentService.CreateFullRefund(ctx, payment.MolliePaymentID)
			if refundErr != nil {
				return nil, fmt.Errorf("failed to initiate refund: %w", refundErr)
			}

			// Send refund issued email
			if refund != nil {
				go func() {
					user, err := r.UserService.GetUserByID(context.Background(), o.UserID.String())
					if err != nil {
						zap.L().Error("failed to retrieve user", zap.String("order_id", o.ID.String()), zap.Error(err))
						return
					}

					refundAmount := utils.FormatDecimal(o.TotalPrice)
					err = es.SendRefundIssuedEmail(*user, lang, refundAmount)
					if err != nil {
						zap.L().Error("failed to send refund issued email", zap.String("order_id", o.ID.String()), zap.Error(err))
					}
				}()
			}
		}

		go func() {
			user, err := r.UserService.GetUserByID(context.Background(), o.UserID.String())
			if err != nil {
				zap.L().Error("failed to retrieve user", zap.String("order_id", o.ID.String()), zap.Error(err))
				return
			}

			err = es.SendOrderCanceledEmail(*user, lang)
			if err != nil {
				zap.L().Error("failed to send order canceled email", zap.String("order_id", o.ID.String()), zap.Error(err))
			}
		}()
	}

	// Map the order to the GraphQL model
	order := ToGQLOrder(o)

	// Publish the order update to the broker
	r.Broker.Publish("orderUpdated", order)
	r.Broker.Publish(fmt.Sprintf("orderUpdated:%s", id), order)

	return order, nil
}

// Address is the resolver for the address field.
func (r *orderResolver) Address(ctx context.Context, obj *model.Order) (*model.Address, error) {
	loader := addressApplication.GetOrderAddressLoader(ctx)

	if loader == nil {
		return nil, fmt.Errorf("no order address loader found")
	}

	// Check for error while loading the address.
	a, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load order address: %w", err)
	}

	// Map the address to the GraphQL model
	addresses := Map(a, func(address *addressDomain.Address) *model.Address {
		return ToGQLAddress(address)
	})

	// Return nil if no addresses were found.
	if len(addresses) == 0 {
		return nil, nil
	}

	// Return the first address found. (Assuming one order belongs to one address)
	return addresses[0], nil
}

// Customer is the resolver for the customer field.
func (r *orderResolver) Customer(ctx context.Context, obj *model.Order) (*model.User, error) {
	loader := userApplication.GetOrderUserLoader(ctx)

	if loader == nil {
		return nil, fmt.Errorf("no order user loader found")
	}

	// Check for error while loading the user.
	a, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load order user: %w", err)
	}

	// Map the user to the GraphQL model
	users := Map(a, func(user *userDomain.User) *model.User {
		return ToGQLUser(user)
	})

	// Return nil if no users were found.
	if len(users) == 0 {
		return nil, nil
	}

	// Return the first user found. (Assuming one order belongs to one user)
	return users[0], nil
}

// Payment is the resolver for the payment field.
func (r *orderResolver) Payment(ctx context.Context, obj *model.Order) (*model.Payment, error) {
	loader := paymentApplication.GetOrderPaymentLoader(ctx)

	if loader == nil {
		return nil, fmt.Errorf("no order payment loader found")
	}

	// Check for error while loading the payment.
	p, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load order payment: %w", err)
	}

	// Map the payment to the GraphQL model
	payments := Map(p, func(payment *paymentDomain.MolliePayment) *model.Payment {
		return ToGQLPayment(payment)
	})

	// Return nil if no payments were found.
	if len(payments) == 0 {
		return nil, nil
	}

	// Return the first payment found. (Assuming one order belongs to one payment)
	return payments[0], nil
}

// Items is the resolver for the items field.
func (r *orderResolver) Items(ctx context.Context, obj *model.Order) ([]*model.OrderItem, error) {
	loader := orderApplication.GetOrderItemLoader(ctx)

	if loader == nil {
		return nil, fmt.Errorf("no order items loader found")
	}

	// Check for error while loading the items.
	i, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load order items: %w", err)
	}

	// Map the items to the GraphQL model
	items := Map(i, func(item *orderDomain.OrderProductRaw) *model.OrderItem {
		return ToGQLOrderItem(item)
	})

	return items, nil
}

// StatusHistory is the resolver for the statusHistory field.
func (r *orderResolver) StatusHistory(ctx context.Context, obj *model.Order) ([]*model.OrderStatusHistory, error) {
	history, err := r.OrderService.GetStatusHistory(ctx, obj.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to load status history: %w", err)
	}

	result := make([]*model.OrderStatusHistory, len(history))
	for i, h := range history {
		result[i] = &model.OrderStatusHistory{
			ID:        h.ID,
			Status:    h.Status,
			ChangedAt: h.ChangedAt,
		}
	}
	return result, nil
}

// DisplayCustomerName is the resolver for the displayCustomerName field.
func (r *orderResolver) DisplayCustomerName(ctx context.Context, obj *model.Order) (string, error) {
	customer, err := r.Customer(ctx, obj)
	if err != nil {
		return "Guest", nil
	}
	if customer != nil {
		return fmt.Sprintf("%s %s", strings.ToUpper(customer.LastName), customer.FirstName), nil
	}
	return "Guest", nil
}

// DisplayAddress is the resolver for the displayAddress field.
func (r *orderResolver) DisplayAddress(ctx context.Context, obj *model.Order) (string, error) {
	address, err := r.Address(ctx, obj)
	if err != nil {
		return "N/A", nil
	}
	if address != nil {
		addressStr := fmt.Sprintf("%s %s", address.StreetName, address.HouseNumber)
		if address.BoxNumber != nil && *address.BoxNumber != "" {
			addressStr += fmt.Sprintf(" %s", *address.BoxNumber)
		}
		addressStr += fmt.Sprintf(", %s %s", address.Postcode, address.MunicipalityName)
		return addressStr, nil
	}
	return "Pickup", nil
}

// Product is the resolver for the product field.
func (r *orderItemResolver) Product(ctx context.Context, obj *model.OrderItem) (*model.Product, error) {
	userLang := utils.GetLang(ctx)
	productID := obj.ProductID

	loader := productApplication.GetOrderItemProductLoader(ctx)

	if loader == nil {
		return nil, fmt.Errorf("no order item product loader found")
	}

	// Check for error while loading the product.
	p, err := loader.Loader.Load(ctx, productID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load order item product: %w", err)
	}

	// Map the product to the GraphQL model
	products := Map(p, func(product *productDomain.Product) *model.Product {
		return ToGQLProduct(product, userLang)
	})

	// Return nil if no products were found.
	if len(products) == 0 {
		return nil, nil
	}

	// Return the first product found. (Assuming one order item belongs to one product)
	return products[0], nil
}

// Choice is the resolver for the choice field.
func (r *orderItemResolver) Choice(ctx context.Context, obj *model.OrderItem) (*model.ProductChoice, error) {
	if obj.ChoiceID == nil {
		return nil, nil
	}
	userLang := utils.GetLang(ctx)

	choice, err := r.ProductService.GetChoiceByID(ctx, *obj.ChoiceID)
	if err != nil {
		return nil, fmt.Errorf("failed to load product choice: %w", err)
	}
	if choice == nil {
		return nil, nil
	}

	return ToGQLProductChoice(choice, userLang), nil
}

// Orders is the resolver for the orders field.
func (r *queryResolver) Orders(ctx context.Context) ([]*model.Order, error) {
	o, err := r.OrderService.GetPaginatedOrders(ctx, 1, 20, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to get orders: %w", err)
	}

	orders := Map(o, func(order *orderDomain.Order) *model.Order {
		return ToGQLOrder(order)
	})

	return orders, nil
}

// Order is the resolver for the order field.
func (r *queryResolver) Order(ctx context.Context, id uuid.UUID) (*model.Order, error) {
	o, _, err := r.OrderService.GetOrderByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get order: %w", err)
	}

	if o == nil {
		return nil, nil
	}

	// Map the order to the GraphQL model
	order := ToGQLOrder(o)

	return order, nil
}

// MyOrders is the resolver for the myOrders field.
func (r *queryResolver) MyOrders(ctx context.Context, first *int, page *int) ([]*model.Order, error) {
	const (
		defaultFirst = 5
		defaultPage  = 1
	)
	f := defaultFirst
	if first != nil && *first > 0 {
		f = *first
	}
	p := defaultPage
	if page != nil && *page > 0 {
		p = *page
	}

	userID := utils.GetUserID(ctx)

	// Cast userID to uuid.UUID
	userUUID, err := uuid.Parse(userID)

	o, err := r.OrderService.GetPaginatedOrders(ctx, p, f, &userUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to get orders: %w", err)
	}

	orders := Map(o, func(order *orderDomain.Order) *model.Order {
		return ToGQLOrder(order)
	})

	return orders, nil
}

// MyOrder is the resolver for the myOrder field.
func (r *queryResolver) MyOrder(ctx context.Context, id uuid.UUID) (*model.Order, error) {
	userID := utils.GetUserID(ctx)

	// @TODO: Check if the user is the owner of the order in the service layer.
	o, _, err := r.OrderService.GetOrderByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get order: %w", err)
	}

	if o == nil {
		return nil, nil
	}

	// @TODO: Remove when the service layer check is implemented.
	if o.UserID.String() != userID {
		return nil, fmt.Errorf("user is not owned by this order")
	}

	// Map the order to the GraphQL model
	order := ToGQLOrder(o)

	return order, nil
}

// OrderCreated is the resolver for the orderCreated field.
func (r *subscriptionResolver) OrderCreated(ctx context.Context) (<-chan *model.Order, error) {
	ch := make(chan *model.Order, 1)
	sub := r.Broker.Subscribe("orderCreated")

	go func() {
		<-ctx.Done()
		r.Broker.Unsubscribe("orderCreated", sub)
		close(ch)
	}()

	go func() {
		for msg := range sub {
			if o, ok := msg.(*model.Order); ok {
				ch <- o
			}
		}
	}()

	return ch, nil
}

// OrderUpdated is the resolver for the orderUpdated field.
func (r *subscriptionResolver) OrderUpdated(ctx context.Context) (<-chan *model.Order, error) {
	ch := make(chan *model.Order, 1)
	sub := r.Broker.Subscribe("orderUpdated")

	go func() {
		<-ctx.Done()
		r.Broker.Unsubscribe("orderUpdated", sub)
		close(ch)
	}()

	go func() {
		for msg := range sub {
			if o, ok := msg.(*model.Order); ok {
				ch <- o
			}
		}
	}()

	return ch, nil
}

// MyOrderUpdated is the resolver for the myOrderUpdated field.
func (r *subscriptionResolver) MyOrderUpdated(ctx context.Context, orderID uuid.UUID) (<-chan *model.Order, error) {
	userID := utils.GetUserID(ctx)
	if userID == "" {
		return nil, fmt.Errorf("UNAUTHENTICATED")
	}
	// @todo: verify the order belongs to this user
	// e.g. if !r.OrderService.BelongsTo(ctx, userID, orderID) { error }

	topic := fmt.Sprintf("orderUpdated:%s", orderID)
	ch := make(chan *model.Order, 1)
	sub := r.Broker.Subscribe(topic)

	go func() {
		<-ctx.Done()
		r.Broker.Unsubscribe(topic, sub)
		close(ch)
	}()

	go func() {
		for msg := range sub {
			if o, ok := msg.(*model.Order); ok {
				ch <- o
			}
		}
	}()

	return ch, nil
}

// Order returns graphql1.OrderResolver implementation.
func (r *Resolver) Order() graphql1.OrderResolver { return &orderResolver{r} }

// OrderItem returns graphql1.OrderItemResolver implementation.
func (r *Resolver) OrderItem() graphql1.OrderItemResolver { return &orderItemResolver{r} }

type orderResolver struct{ *Resolver }
type orderItemResolver struct{ *Resolver }
