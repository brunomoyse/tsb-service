package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"fmt"
	"log"
	graphql1 "tsb-service/internal/api/graphql"
	"tsb-service/internal/api/graphql/model"
	addressApplication "tsb-service/internal/modules/address/application"
	addressDomain "tsb-service/internal/modules/address/domain"
	orderApplication "tsb-service/internal/modules/order/application"
	orderDomain "tsb-service/internal/modules/order/domain"
	paymentApplication "tsb-service/internal/modules/payment/application"
	paymentDomain "tsb-service/internal/modules/payment/domain"
	productApplication "tsb-service/internal/modules/product/application"
	productDomain "tsb-service/internal/modules/product/domain"
	userApplication "tsb-service/internal/modules/user/application"
	userDomain "tsb-service/internal/modules/user/domain"
	"tsb-service/pkg/utils"
	es "tsb-service/services/email/scaleway"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input model.CreateOrderInput) (*model.Order, error) {
	// 1) Authenticated user
	userID := utils.GetUserID(ctx)
	if userID == "" {
		return nil, fmt.Errorf("UNAUTHENTICATED: please login")
	}
	userUUID, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// 2) Fetch products and build price map
	prodCount := len(input.Items)
	ids := make([]string, prodCount)
	for i, op := range input.Items {
		ids[i] = op.ProductID.String()
	}
	products, err := r.ProductService.GetProductsByIDs(ctx, ids)
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve products: %w", err)
	}
	priceMap := make(map[uuid.UUID]decimal.Decimal, len(products))
	for _, p := range products {
		priceMap[p.ID] = p.Price
	}

	// 3) Compute line totals and overall total
	rawItems := make([]orderDomain.OrderProductRaw, 0, prodCount)
	total := decimal.Zero
	for _, op := range input.Items {
		pid := op.ProductID
		unitPrice, ok := priceMap[pid]
		if !ok {
			return nil, fmt.Errorf("product %s not found", pid)
		}
		qty := int64(op.Quantity)
		lineTotal := unitPrice.Mul(decimal.NewFromInt(qty))
		total = total.Add(lineTotal)
		rawItems = append(rawItems, orderDomain.OrderProductRaw{
			ProductID:  pid,
			Quantity:   qty,
			UnitPrice:  unitPrice,
			TotalPrice: lineTotal,
		})
	}

	// 4) Determine order type
	var odType orderDomain.OrderType
	switch input.OrderType {
	case model.OrderTypeEnumDelivery:
		odType = orderDomain.OrderTypeDelivery
	default:
		odType = orderDomain.OrderTypePickUp
	}

	// 5) Enforce minimum amounts
	if odType == orderDomain.OrderTypePickUp && total.LessThan(decimal.NewFromInt(20)) {
		return nil, fmt.Errorf("minimum order amount for pickup is 20")
	}
	if odType == orderDomain.OrderTypeDelivery && total.LessThan(decimal.NewFromInt(25)) {
		return nil, fmt.Errorf("minimum order amount for delivery is 25")
	}

	// 6) Compute delivery fee if needed
	fee := decimal.NewFromInt(0)
	if odType == orderDomain.OrderTypeDelivery {
		if input.AddressID == nil {
			return nil, fmt.Errorf("addressID required for delivery")
		}

		addr, err := r.AddressService.GetAddressByID(ctx, *input.AddressID)
		if err != nil {
			return nil, fmt.Errorf("failed to retrieve address: %w", err)
		}
		if addr == nil {
			return nil, fmt.Errorf("address not found")
		}
		if addr.Distance >= 9000 {
			return nil, fmt.Errorf("address too far for delivery")
		}

		var dFee int64
		switch {
		case addr.Distance < 4000:
			dFee = 0
		case addr.Distance < 5000:
			dFee = 1
		case addr.Distance < 6000:
			dFee = 2
		case addr.Distance < 7000:
			dFee = 3
		case addr.Distance < 8000:
			dFee = 4
		case addr.Distance < 9000:
			dFee = 5
		default:
			dFee = 10
		}
		fee = decimal.NewFromInt(dFee)
		total = total.Add(fee)
	}

	// Compute total discount if any
	totalDiscount := decimal.Zero
	// Loop through the items and check if any discount is applicable (isDiscountable property)
	if odType == orderDomain.OrderTypePickUp {
		for _, p := range products {
			if p.IsDiscountable {
				// Assuming a discount of 10%
				discount := p.Price.Mul(decimal.NewFromFloat(0.10))
				totalDiscount = totalDiscount.Add(discount)
			}
		}
	}

	var extras []orderDomain.OrderExtra
	if input.OrderExtra != nil {
		extras = make([]orderDomain.OrderExtra, len(input.OrderExtra))
		for i, extraIn := range input.OrderExtra {
			extras[i] = orderDomain.OrderExtra{
				Name:    extraIn.Name,
				Options: extraIn.Options,
			}
		}
	}

	tempOrder := orderDomain.NewOrder(
		userUUID,
		odType,
		input.IsOnlinePayment,
		input.AddressID,
		input.AddressExtra,
		input.OrderNote,
		extras,
		&fee,
		totalDiscount,
	)

	// 8) Persist via service
	order, itemsRaw, err := r.OrderService.CreateOrder(ctx, tempOrder, &rawItems)
	if err != nil {
		return nil, fmt.Errorf("failed to create order: %w", err)
	}

	// 9) Enrich each raw item with its product details
	//    build a lookup map from product ID → product info
	prodMap := make(map[uuid.UUID]productDomain.ProductOrderDetails, len(products))
	for _, p := range products {
		prodMap[p.ID] = *p
	}

	// now map persisted raw items → full OrderProduct
	items := make([]orderDomain.OrderProduct, len(*itemsRaw))
	for i, ir := range *itemsRaw {
		pd, ok := prodMap[ir.ProductID]
		if !ok {
			// this should never happen—just in case
			return nil, fmt.Errorf("missing product details for %s", ir.ProductID)
		}
		items[i] = orderDomain.OrderProduct{
			Product: orderDomain.Product{
				ID:           pd.ID,
				Code:         pd.Code,
				CategoryName: pd.CategoryName,
				Name:         pd.Name,
			},
			Quantity:   ir.Quantity,
			UnitPrice:  ir.UnitPrice,
			TotalPrice: ir.TotalPrice,
		}
	}

	user, err := r.UserService.GetUserByID(ctx, order.UserID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve user: %w", err)
	}

	// Handle payment creation if needed.
	if input.IsOnlinePayment {
		address := &addressDomain.Address{}
		if odType == orderDomain.OrderTypeDelivery {
			if input.AddressID == nil {
				return nil, fmt.Errorf("addressID required for delivery")
			}

			address, err = r.AddressService.GetAddressByID(ctx, *input.AddressID)
			if err != nil {
				return nil, fmt.Errorf("failed to retrieve address: %w", err)
			}
		}
		molliePayment, err := r.PaymentService.CreatePayment(ctx, *order, items, *user, address)
		if err != nil || molliePayment == nil {
			return nil, fmt.Errorf("failed to create payment: %w", err)
		}
	} else {
		// If offline payment, send the notification e-mail already
		go func() {
			err = es.SendOrderPendingEmail(*user, "fr", *order, items)
			if err != nil {
				log.Printf("failed to send order pending email: %v", err)
			}
		}()
	}

	// 10) Map to GraphQL model
	gql := ToGQLOrder(order)

	// 11) Publish subscription
	r.Broker.Publish("orderCreated", gql)

	return gql, nil
}

// UpdateOrder is the resolver for the updateOrder field.
func (r *mutationResolver) UpdateOrder(ctx context.Context, id uuid.UUID, input model.UpdateOrderInput) (*model.Order, error) {
	err := r.OrderService.UpdateOrderStatus(ctx, id, *input.Status)
	if err != nil {
		return nil, fmt.Errorf("failed to update order status: %w", err)
	}

	// Fetch the updated order
	o, opRaw, err := r.OrderService.GetOrderByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get order: %w", err)
	}

	// If new status is "CONFIRMED", send the confirmation email
	if o.OrderStatus == orderDomain.OrderStatusConfirmed {
		go func() {
			type OrderProduct struct {
				Product    productDomain.Product
				Quantity   int64
				UnitPrice  decimal.Decimal
				TotalPrice decimal.Decimal
			}

			user, err := r.UserService.GetUserByID(context.Background(), o.UserID.String())
			if err != nil {
				log.Printf("failed to retrieve user: %v", err)
				return
			}

			// 1) collect product IDs as strings
			raws := *opRaw
			ids := make([]string, len(raws))
			for i, ir := range raws {
				ids[i] = ir.ProductID.String()
			}

			// 2) fetch all products in one go
			prodDetailsSlice, err := r.ProductService.GetProductsByIDs(context.Background(), ids)
			if err != nil {
				log.Printf("failed to retrieve products: %v", err)
				return // or return err if you’re in a function that can
			}

			// 3) build a map for quick lookup
			prodMap := make(map[uuid.UUID]productDomain.ProductOrderDetails, len(prodDetailsSlice))
			for _, pd := range prodDetailsSlice {
				prodMap[pd.ID] = *pd
			}

			// 4) enrich raws into your final items
			items := make([]orderDomain.OrderProduct, len(raws))
			for i, ir := range raws {
				pd, ok := prodMap[ir.ProductID]
				if !ok {
					log.Printf("missing product details for %s", ir.ProductID)
					return
				}
				items[i] = orderDomain.OrderProduct{
					Product: orderDomain.Product{
						ID:           pd.ID,
						Code:         pd.Code,
						CategoryName: pd.CategoryName,
						Name:         pd.Name,
					},
					Quantity:   ir.Quantity,
					UnitPrice:  ir.UnitPrice,
					TotalPrice: ir.TotalPrice,
				}
			}

			var address *addressDomain.Address
			if o.AddressID != nil {
				address, err = r.AddressService.GetAddressByID(context.Background(), *o.AddressID)
				if err != nil {
					log.Printf("failed to retrieve address: %v", err)
					return
				}
			}

			err = es.SendOrderConfirmedEmail(*user, "fr", *o, items, address)
			if err != nil {
				log.Printf("failed to send order pending email: %v", err)
			}
		}()
	}

	// If new status is "CANCELED", refund & send the cancellation email
	if o.OrderStatus == orderDomain.OrderStatusCancelled {
		payment, err := r.PaymentService.GetPaymentByOrderID(ctx, o.ID)
		if err != nil && payment != nil {
			_, err = r.PaymentService.CreateFullRefund(ctx, payment.MolliePaymentID)
			if err != nil {
				return nil, fmt.Errorf("failed to initiate refund: %w", err)
			}
		}

		go func() {
			user, err := r.UserService.GetUserByID(context.Background(), o.UserID.String())
			if err != nil {
				log.Printf("failed to retrieve user: %v", err)
				return
			}

			err = es.SendOrderCanceledEmail(*user, "fr")
			if err != nil {
				log.Printf("failed to send order canceled email: %v", err)
			}
		}()
	}

	// Map the order to the GraphQL model
	order := ToGQLOrder(o)

	// Publish the order update to the broker
	r.Broker.Publish("orderUpdated", order)
	r.Broker.Publish(fmt.Sprintf("orderUpdated:%s", id), order)

	return order, nil
}

// Address is the resolver for the address field.
func (r *orderResolver) Address(ctx context.Context, obj *model.Order) (*model.Address, error) {
	loader := addressApplication.GetOrderAddressLoader(ctx)

	if loader == nil {
		return nil, fmt.Errorf("no order address loader found")
	}

	// Check for error while loading the address.
	a, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load order address: %w", err)
	}

	// Map the address to the GraphQL model
	addresses := Map(a, func(address *addressDomain.Address) *model.Address {
		return ToGQLAddress(address)
	})

	// Return nil if no addresses were found.
	if len(addresses) == 0 {
		return nil, nil
	}

	// Return the first address found. (Assuming one order belongs to one address)
	return addresses[0], nil
}

// Customer is the resolver for the customer field.
func (r *orderResolver) Customer(ctx context.Context, obj *model.Order) (*model.User, error) {
	loader := userApplication.GetOrderUserLoader(ctx)

	if loader == nil {
		return nil, fmt.Errorf("no order user loader found")
	}

	// Check for error while loading the user.
	a, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load order user: %w", err)
	}

	// Map the user to the GraphQL model
	users := Map(a, func(user *userDomain.User) *model.User {
		return ToGQLUser(user)
	})

	// Return nil if no users were found.
	if len(users) == 0 {
		return nil, nil
	}

	// Return the first user found. (Assuming one order belongs to one user)
	return users[0], nil
}

// Payment is the resolver for the payment field.
func (r *orderResolver) Payment(ctx context.Context, obj *model.Order) (*model.Payment, error) {
	loader := paymentApplication.GetOrderPaymentLoader(ctx)

	if loader == nil {
		return nil, fmt.Errorf("no order payment loader found")
	}

	// Check for error while loading the payment.
	p, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load order payment: %w", err)
	}

	// Map the payment to the GraphQL model
	payments := Map(p, func(payment *paymentDomain.MolliePayment) *model.Payment {
		return ToGQLPayment(payment)
	})

	// Return nil if no payments were found.
	if len(payments) == 0 {
		return nil, nil
	}

	// Return the first payment found. (Assuming one order belongs to one payment)
	return payments[0], nil
}

// Items is the resolver for the items field.
func (r *orderResolver) Items(ctx context.Context, obj *model.Order) ([]*model.OrderItem, error) {
	loader := orderApplication.GetOrderItemLoader(ctx)

	if loader == nil {
		return nil, fmt.Errorf("no order items loader found")
	}

	// Check for error while loading the items.
	i, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load order items: %w", err)
	}

	// Map the items to the GraphQL model
	items := Map(i, func(item *orderDomain.OrderProductRaw) *model.OrderItem {
		return ToGQLOrderItem(item)
	})

	return items, nil
}

// Product is the resolver for the product field.
func (r *orderItemResolver) Product(ctx context.Context, obj *model.OrderItem) (*model.Product, error) {
	userLang := utils.GetLang(ctx)
	productID := obj.ProductID

	loader := productApplication.GetOrderItemProductLoader(ctx)

	if loader == nil {
		return nil, fmt.Errorf("no order item product loader found")
	}

	// Check for error while loading the product.
	p, err := loader.Loader.Load(ctx, productID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load order item product: %w", err)
	}

	// Map the product to the GraphQL model
	products := Map(p, func(product *productDomain.Product) *model.Product {
		return ToGQLProduct(product, userLang)
	})

	// Return nil if no products were found.
	if len(products) == 0 {
		return nil, nil
	}

	// Return the first product found. (Assuming one order item belongs to one product)
	return products[0], nil
}

// Orders is the resolver for the orders field.
func (r *queryResolver) Orders(ctx context.Context) ([]*model.Order, error) {
	o, err := r.OrderService.GetPaginatedOrders(ctx, 1, 20, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to get orders: %w", err)
	}

	orders := Map(o, func(order *orderDomain.Order) *model.Order {
		return ToGQLOrder(order)
	})

	return orders, nil
}

// Order is the resolver for the order field.
func (r *queryResolver) Order(ctx context.Context, id uuid.UUID) (*model.Order, error) {
	o, _, err := r.OrderService.GetOrderByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get order: %w", err)
	}

	if o == nil {
		return nil, nil
	}

	// Map the order to the GraphQL model
	order := ToGQLOrder(o)

	return order, nil
}

// MyOrders is the resolver for the myOrders field.
func (r *queryResolver) MyOrders(ctx context.Context, first *int, page *int) ([]*model.Order, error) {
	const (
		defaultFirst = 5
		defaultPage  = 1
	)
	f := defaultFirst
	if first != nil && *first > 0 {
		f = *first
	}
	p := defaultPage
	if page != nil && *page > 0 {
		p = *page
	}

	userID := utils.GetUserID(ctx)

	// Cast userID to uuid.UUID
	userUUID, err := uuid.Parse(userID)

	o, err := r.OrderService.GetPaginatedOrders(ctx, p, f, &userUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to get orders: %w", err)
	}

	orders := Map(o, func(order *orderDomain.Order) *model.Order {
		return ToGQLOrder(order)
	})

	return orders, nil
}

// MyOrder is the resolver for the myOrder field.
func (r *queryResolver) MyOrder(ctx context.Context, id uuid.UUID) (*model.Order, error) {
	userID := utils.GetUserID(ctx)

	// @TODO: Check if the user is the owner of the order in the service layer.
	o, _, err := r.OrderService.GetOrderByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get order: %w", err)
	}

	if o == nil {
		return nil, nil
	}

	// @TODO: Remove when the service layer check is implemented.
	if o.UserID.String() != userID {
		return nil, fmt.Errorf("user is not owned by this order")
	}

	// Map the order to the GraphQL model
	order := ToGQLOrder(o)

	return order, nil
}

// OrderCreated is the resolver for the orderCreated field.
func (r *subscriptionResolver) OrderCreated(ctx context.Context) (<-chan *model.Order, error) {
	ch := make(chan *model.Order, 1)
	sub := r.Broker.Subscribe("orderCreated")

	go func() {
		<-ctx.Done()
		r.Broker.Unsubscribe("orderCreated", sub)
		close(ch)
	}()

	go func() {
		for msg := range sub {
			if o, ok := msg.(*model.Order); ok {
				ch <- o
			}
		}
	}()

	return ch, nil
}

// OrderUpdated is the resolver for the orderUpdated field.
func (r *subscriptionResolver) OrderUpdated(ctx context.Context) (<-chan *model.Order, error) {
	ch := make(chan *model.Order, 1)
	sub := r.Broker.Subscribe("orderUpdated")

	go func() {
		<-ctx.Done()
		r.Broker.Unsubscribe("orderUpdated", sub)
		close(ch)
	}()

	go func() {
		for msg := range sub {
			if o, ok := msg.(*model.Order); ok {
				ch <- o
			}
		}
	}()

	return ch, nil
}

// MyOrderUpdated is the resolver for the myOrderUpdated field.
func (r *subscriptionResolver) MyOrderUpdated(ctx context.Context, orderID uuid.UUID) (<-chan *model.Order, error) {
	userID := utils.GetUserID(ctx)
	if userID == "" {
		return nil, fmt.Errorf("UNAUTHENTICATED")
	}
	// @todo: verify the order belongs to this user
	// e.g. if !r.OrderService.BelongsTo(ctx, userID, orderID) { error }

	topic := fmt.Sprintf("orderUpdated:%s", orderID)
	ch := make(chan *model.Order, 1)
	sub := r.Broker.Subscribe(topic)

	go func() {
		<-ctx.Done()
		r.Broker.Unsubscribe(topic, sub)
		close(ch)
	}()

	go func() {
		for msg := range sub {
			if o, ok := msg.(*model.Order); ok {
				ch <- o
			}
		}
	}()

	return ch, nil
}

// Mutation returns graphql1.MutationResolver implementation.
func (r *Resolver) Mutation() graphql1.MutationResolver { return &mutationResolver{r} }

// Order returns graphql1.OrderResolver implementation.
func (r *Resolver) Order() graphql1.OrderResolver { return &orderResolver{r} }

// OrderItem returns graphql1.OrderItemResolver implementation.
func (r *Resolver) OrderItem() graphql1.OrderItemResolver { return &orderItemResolver{r} }

// Subscription returns graphql1.SubscriptionResolver implementation.
func (r *Resolver) Subscription() graphql1.SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type orderResolver struct{ *Resolver }
type orderItemResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
