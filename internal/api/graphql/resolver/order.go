package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"fmt"
	graphql1 "tsb-service/internal/api/graphql"
	"tsb-service/internal/api/graphql/model"
	addressApplication "tsb-service/internal/modules/address/application"
	addressDomain "tsb-service/internal/modules/address/domain"
	orderApplication "tsb-service/internal/modules/order/application"
	"tsb-service/internal/modules/order/domain"
	paymentApplication "tsb-service/internal/modules/payment/application"
	paymentDomain "tsb-service/internal/modules/payment/domain"
	userApplication "tsb-service/internal/modules/user/application"
	userDomain "tsb-service/internal/modules/user/domain"
)

// Address is the resolver for the address field.
func (r *orderResolver) Address(ctx context.Context, obj *model.Order) (*model.Address, error) {
	loader := addressApplication.GetOrderAddressLoader(ctx)

	if loader == nil {
		return nil, fmt.Errorf("no order address loader found")
	}

	// Check for error while loading the address.
	a, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load order address: %w", err)
	}

	// Map the address to the GraphQL model
	addresses := Map(a, func(address *addressDomain.Address) *model.Address {
		return ToGQLAddress(address)
	})

	// Return nil if no addresses were found.
	if len(addresses) == 0 {
		return nil, nil
	}

	// Return the first address found. (Assuming one order belongs to one address)
	return addresses[0], nil
}

// Customer is the resolver for the customer field.
func (r *orderResolver) Customer(ctx context.Context, obj *model.Order) (*model.User, error) {
	loader := userApplication.GetOrderUserLoader(ctx)

	if loader == nil {
		return nil, fmt.Errorf("no order user loader found")
	}

	// Check for error while loading the user.
	a, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load order user: %w", err)
	}

	// Map the user to the GraphQL model
	users := Map(a, func(user *userDomain.User) *model.User {
		return ToGQLUser(user)
	})

	// Return nil if no users were found.
	if len(users) == 0 {
		return nil, nil
	}

	// Return the first user found. (Assuming one order belongs to one user)
	return users[0], nil
}

// Payment is the resolver for the payment field.
func (r *orderResolver) Payment(ctx context.Context, obj *model.Order) (*model.Payment, error) {
	loader := paymentApplication.GetOrderPaymentLoader(ctx)

	if loader == nil {
		return nil, fmt.Errorf("no order payment loader found")
	}

	// Check for error while loading the payment.
	p, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load order payment: %w", err)
	}

	// Map the payment to the GraphQL model
	payments := Map(p, func(payment *paymentDomain.MolliePayment) *model.Payment {
		return ToGQLPayment(payment)
	})

	// Return nil if no payments were found.
	if len(payments) == 0 {
		return nil, nil
	}

	// Return the first payment found. (Assuming one order belongs to one payment)
	return payments[0], nil
}

// Items is the resolver for the items field.
func (r *orderResolver) Items(ctx context.Context, obj *model.Order) ([]*model.OrderItem, error) {
	loader := orderApplication.GetOrderItemLoader(ctx)

	if loader == nil {
		return nil, fmt.Errorf("no order items loader found")
	}

	// Check for error while loading the items.
	i, err := loader.Loader.Load(ctx, obj.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to load order items: %w", err)
	}

	// Map the items to the GraphQL model
	items := Map(i, func(item *domain.OrderProductRaw) *model.OrderItem {
		return ToGQLOrderItem(item)
	})

	return items, nil
}

// Product is the resolver for the product field.
func (r *orderItemResolver) Product(ctx context.Context, obj *model.OrderItem) (*model.Product, error) {
	panic(fmt.Errorf("not implemented: Product - product"))
}

// Orders is the resolver for the orders field.
func (r *queryResolver) Orders(ctx context.Context) ([]*model.Order, error) {
	o, err := r.OrderService.GetPaginatedOrders(ctx, 1, 20, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to get orders: %w", err)
	}

	orders := Map(o, func(order *domain.Order) *model.Order {
		return ToGQLOrder(order)
	})

	return orders, nil
}

// Order returns graphql1.OrderResolver implementation.
func (r *Resolver) Order() graphql1.OrderResolver { return &orderResolver{r} }

// OrderItem returns graphql1.OrderItemResolver implementation.
func (r *Resolver) OrderItem() graphql1.OrderItemResolver { return &orderItemResolver{r} }

// Query returns graphql1.QueryResolver implementation.
func (r *Resolver) Query() graphql1.QueryResolver { return &queryResolver{r} }

type orderResolver struct{ *Resolver }
type orderItemResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
