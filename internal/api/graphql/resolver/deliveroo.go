package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"
	"time"
	graphql1 "tsb-service/internal/api/graphql"
	"tsb-service/internal/api/graphql/model"
	"tsb-service/internal/modules/order/domain"
	"tsb-service/services/deliveroo"

	"github.com/google/uuid"
)

// AcceptPlatformOrder is the resolver for the acceptPlatformOrder field.
func (r *mutationResolver) AcceptPlatformOrder(ctx context.Context, input model.AcceptOrderInput) (*model.PlatformOrder, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch input.Source {
	case model.OrderSourceDeliveroo:
		adapter := r.DeliverooService.GetAdapter()

		// Use UpdateOrder to accept the order
		acceptReq := deliveroo.UpdateOrderRequest{
			Status: deliveroo.OrderUpdateAccepted,
			Notes:  input.Notes,
		}

		if err := adapter.UpdateOrder(ctx, input.OrderID.String(), acceptReq); err != nil {
			return nil, fmt.Errorf("failed to accept Deliveroo order: %w", err)
		}

		// Fetch the updated order
		order, err := adapter.GetOrderV2(ctx, input.OrderID.String())
		if err != nil {
			return nil, fmt.Errorf("failed to fetch updated order: %w", err)
		}

		return convertDeliverooOrderToPlatformOrder(order, model.OrderSourceDeliveroo), nil

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", input.Source)
	}
}

// RejectPlatformOrder is the resolver for the rejectPlatformOrder field.
func (r *mutationResolver) RejectPlatformOrder(ctx context.Context, input model.RejectOrderInput) (*model.PlatformOrder, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch input.Source {
	case model.OrderSourceDeliveroo:
		adapter := r.DeliverooService.GetAdapter()

		// Convert reason string to RejectReason
		reason := deliveroo.RejectReason(input.Reason)

		// Use UpdateOrder to reject the order
		rejectReq := deliveroo.UpdateOrderRequest{
			Status:       deliveroo.OrderUpdateRejected,
			RejectReason: &reason,
			Notes:        input.Notes,
		}

		if err := adapter.UpdateOrder(ctx, input.OrderID.String(), rejectReq); err != nil {
			return nil, fmt.Errorf("failed to reject Deliveroo order: %w", err)
		}

		// Fetch the updated order
		order, err := adapter.GetOrderV2(ctx, input.OrderID.String())
		if err != nil {
			return nil, fmt.Errorf("failed to fetch updated order: %w", err)
		}

		return convertDeliverooOrderToPlatformOrder(order, model.OrderSourceDeliveroo), nil

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", input.Source)
	}
}

// UpdatePlatformOrderPrepStage is the resolver for the updatePlatformOrderPrepStage field.
func (r *mutationResolver) UpdatePlatformOrderPrepStage(ctx context.Context, input model.UpdatePrepStageInput) (*model.PlatformOrder, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch input.Source {
	case model.OrderSourceDeliveroo:
		adapter := r.DeliverooService.GetAdapter()

		prepStageReq := deliveroo.CreatePrepStageRequest{
			Stage:      convertGraphQLPrepStageToDeliveroo(input.Stage),
			OccurredAt: time.Now(),
			Delay:      input.Delay,
		}

		if err := adapter.CreatePrepStage(ctx, input.OrderID.String(), prepStageReq); err != nil {
			return nil, fmt.Errorf("failed to update prep stage: %w", err)
		}

		// Fetch updated order
		order, err := adapter.GetOrderV2(ctx, input.OrderID.String())
		if err != nil {
			return nil, fmt.Errorf("failed to fetch updated order: %w", err)
		}

		return convertDeliverooOrderToPlatformOrder(order, model.OrderSourceDeliveroo), nil

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", input.Source)
	}
}

// UpdateItemAvailabilities is the resolver for the updateItemAvailabilities field.
func (r *mutationResolver) UpdateItemAvailabilities(ctx context.Context, source model.OrderSource, brandID uuid.UUID, siteID uuid.UUID, items []*model.UpdateItemAvailabilityInput) (*model.ItemUnavailabilityList, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch source {
	case model.OrderSourceDeliveroo:
		adapter := r.DeliverooService.GetAdapter()

		unavailabilities := make([]deliveroo.ItemUnavailability, len(items))
		for i, item := range items {
			unavailabilities[i] = deliveroo.ItemUnavailability{
				ItemID: item.ItemID.String(),
				Status: convertGraphQLAvailabilityStatusToDeliveroo(item.Status),
			}
		}

		req := deliveroo.UpdateItemUnavailabilitiesRequest{
			ItemUnavailabilities: unavailabilities,
		}

		if err := adapter.UpdateItemUnavailabilitiesV2(ctx, brandID.String(), siteID.String(), req); err != nil {
			return nil, fmt.Errorf("failed to update item availabilities: %w", err)
		}

		// Fetch updated unavailabilities
		response, err := adapter.GetItemUnavailabilitiesV2(ctx, brandID.String(), siteID.String())
		if err != nil {
			return nil, fmt.Errorf("failed to fetch updated unavailabilities: %w", err)
		}

		return convertDeliverooUnavailabilityList(response), nil

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", source)
	}
}

// ReplaceAllUnavailabilities is the resolver for the replaceAllUnavailabilities field.
func (r *mutationResolver) ReplaceAllUnavailabilities(ctx context.Context, source model.OrderSource, brandID uuid.UUID, siteID uuid.UUID, input model.ReplaceAllUnavailabilitiesInput) (*model.ItemUnavailabilityList, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch source {
	case model.OrderSourceDeliveroo:
		adapter := r.DeliverooService.GetAdapter()

		unavailableIDs := make([]string, len(input.UnavailableIds))
		for i, id := range input.UnavailableIds {
			unavailableIDs[i] = id.String()
		}

		hiddenIDs := make([]string, len(input.HiddenIds))
		for i, id := range input.HiddenIds {
			hiddenIDs[i] = id.String()
		}

		req := deliveroo.ReplaceAllUnavailabilitiesRequest{
			UnavailableIDs: unavailableIDs,
			HiddenIDs:      hiddenIDs,
		}

		if err := adapter.ReplaceItemUnavailabilitiesV2(ctx, brandID.String(), siteID.String(), req); err != nil {
			return nil, fmt.Errorf("failed to replace unavailabilities: %w", err)
		}

		// Fetch updated unavailabilities
		response, err := adapter.GetItemUnavailabilitiesV2(ctx, brandID.String(), siteID.String())
		if err != nil {
			return nil, fmt.Errorf("failed to fetch updated unavailabilities: %w", err)
		}

		return convertDeliverooUnavailabilityList(response), nil

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", source)
	}
}

// MarkItemsAvailable is the resolver for the markItemsAvailable field.
func (r *mutationResolver) MarkItemsAvailable(ctx context.Context, source model.OrderSource, brandID uuid.UUID, siteID uuid.UUID, itemIds []uuid.UUID) (*model.ItemUnavailabilityList, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch source {
	case model.OrderSourceDeliveroo:
		adapter := r.DeliverooService.GetAdapter()

		unavailabilities := make([]deliveroo.ItemUnavailability, len(itemIds))
		for i, id := range itemIds {
			unavailabilities[i] = deliveroo.ItemUnavailability{
				ItemID: id.String(),
				Status: deliveroo.StatusAvailable,
			}
		}

		req := deliveroo.UpdateItemUnavailabilitiesRequest{
			ItemUnavailabilities: unavailabilities,
		}

		if err := adapter.UpdateItemUnavailabilitiesV2(ctx, brandID.String(), siteID.String(), req); err != nil {
			return nil, fmt.Errorf("failed to mark items available: %w", err)
		}

		// Fetch updated unavailabilities
		response, err := adapter.GetItemUnavailabilitiesV2(ctx, brandID.String(), siteID.String())
		if err != nil {
			return nil, fmt.Errorf("failed to fetch updated unavailabilities: %w", err)
		}

		return convertDeliverooUnavailabilityList(response), nil

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", source)
	}
}

// MarkItemsSoldOut is the resolver for the markItemsSoldOut field.
func (r *mutationResolver) MarkItemsSoldOut(ctx context.Context, source model.OrderSource, brandID uuid.UUID, siteID uuid.UUID, itemIds []uuid.UUID) (*model.ItemUnavailabilityList, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch source {
	case model.OrderSourceDeliveroo:
		adapter := r.DeliverooService.GetAdapter()

		unavailabilities := make([]deliveroo.ItemUnavailability, len(itemIds))
		for i, id := range itemIds {
			unavailabilities[i] = deliveroo.ItemUnavailability{
				ItemID: id.String(),
				Status: deliveroo.StatusUnavailable,
			}
		}

		req := deliveroo.UpdateItemUnavailabilitiesRequest{
			ItemUnavailabilities: unavailabilities,
		}

		if err := adapter.UpdateItemUnavailabilitiesV2(ctx, brandID.String(), siteID.String(), req); err != nil {
			return nil, fmt.Errorf("failed to mark items sold out: %w", err)
		}

		// Fetch updated unavailabilities
		response, err := adapter.GetItemUnavailabilitiesV2(ctx, brandID.String(), siteID.String())
		if err != nil {
			return nil, fmt.Errorf("failed to fetch updated unavailabilities: %w", err)
		}

		return convertDeliverooUnavailabilityList(response), nil

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", source)
	}
}

// UpdatePLUs is the resolver for the updatePLUs field.
func (r *mutationResolver) UpdatePLUs(ctx context.Context, source model.OrderSource, brandID uuid.UUID, menuID uuid.UUID, input model.UpdatePLUsInput) (bool, error) {
	if r.DeliverooService == nil {
		return false, fmt.Errorf("deliveroo service not configured")
	}

	switch source {
	case model.OrderSourceDeliveroo:
		adapter := r.DeliverooService.GetAdapter()

		mappings := make(deliveroo.UpdatePLUsRequest, len(input.Mappings))
		for i, mapping := range input.Mappings {
			mappings[i] = deliveroo.PLUMapping{
				ItemID: mapping.ItemID.String(),
				PLU:    mapping.Plu,
			}
		}

		if err := adapter.UpdatePLUs(ctx, brandID.String(), menuID.String(), mappings); err != nil {
			return false, fmt.Errorf("failed to update PLUs: %w", err)
		}

		return true, nil

	case model.OrderSourceUber:
		return false, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return false, fmt.Errorf("invalid source for platform order: %s", source)
	}
}

// SyncMenuToPlatform is the resolver for the syncMenuToPlatform field.
func (r *mutationResolver) SyncMenuToPlatform(ctx context.Context, source model.OrderSource, brandID uuid.UUID, menuID uuid.UUID) (bool, error) {
	if r.DeliverooService == nil {
		return false, fmt.Errorf("deliveroo service not configured")
	}

	switch source {
	case model.OrderSourceDeliveroo:
		// Fetch categories and products from the database
		categories, err := r.ProductService.GetCategories(ctx)
		if err != nil {
			return false, fmt.Errorf("failed to fetch categories: %w", err)
		}

		products, err := r.ProductService.GetProducts(ctx)
		if err != nil {
			return false, fmt.Errorf("failed to fetch products: %w", err)
		}

		// Sync menu using the Deliveroo service
		if err := r.DeliverooService.SyncMenu(ctx, categories, products); err != nil {
			return false, fmt.Errorf("failed to sync menu to Deliveroo: %w", err)
		}

		return true, nil

	case model.OrderSourceUber:
		return false, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return false, fmt.Errorf("invalid source for platform order: %s", source)
	}
}

// PlatformData is the resolver for the platformData field.
func (r *orderResolver) PlatformData(ctx context.Context, obj *model.Order) (*model.PlatformOrder, error) {
	// Only platform orders have platform data
	if obj.Source == model.OrderSourceTokyo {
		return nil, nil
	}

	// Get the domain order to access PlatformData JSONB field
	domainOrder, _, err := r.OrderService.GetOrderByID(ctx, obj.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get order: %w", err)
	}

	if domainOrder == nil || domainOrder.PlatformData.IsNull() {
		return nil, nil
	}

	// Unmarshal based on source
	switch obj.Source {
	case model.OrderSourceDeliveroo:
		var deliverooOrder deliveroo.Order
		if err := domainOrder.PlatformData.Unmarshal(&deliverooOrder); err != nil {
			return nil, fmt.Errorf("failed to unmarshal Deliveroo platform data: %w", err)
		}
		return convertDeliverooOrderToPlatformOrder(&deliverooOrder, model.OrderSourceDeliveroo), nil

	case model.OrderSourceUber:
		// Uber Eats integration not yet implemented
		return nil, nil

	default:
		return nil, nil
	}
}

// PlatformOrders is the resolver for the platformOrders field.
func (r *queryResolver) PlatformOrders(ctx context.Context, source model.OrderSource, brandID *uuid.UUID, restaurantID *uuid.UUID, filter *model.PlatformOrderFilter) (*model.PlatformOrdersConnection, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch source {
	case model.OrderSourceDeliveroo:
		adapter := r.DeliverooService.GetAdapter()

		req := deliveroo.GetOrdersV2Request{}
		if filter != nil {
			if filter.StartDate != nil {
				req.StartDate = filter.StartDate
			}
			if filter.EndDate != nil {
				req.EndDate = filter.EndDate
			}
			if filter.LiveOrdersOnly != nil {
				req.LiveOrders = *filter.LiveOrdersOnly
			}
			if filter.Cursor != nil {
				req.Cursor = filter.Cursor
			}
		}

		if brandID == nil || restaurantID == nil {
			return nil, fmt.Errorf("brandID and restaurantID are required for Deliveroo orders")
		}

		response, err := adapter.GetOrdersV2(ctx, brandID.String(), restaurantID.String(), req)
		if err != nil {
			return nil, fmt.Errorf("failed to fetch Deliveroo orders: %w", err)
		}

		orders := make([]*model.PlatformOrder, len(response.Orders))
		for i, order := range response.Orders {
			orders[i] = convertDeliverooOrderToPlatformOrder(&order, model.OrderSourceDeliveroo)
		}

		hasMore := response.Next != nil
		var nextCursor *string
		if response.Next != nil {
			nextCursor = response.Next
		}

		return &model.PlatformOrdersConnection{
			Orders:     orders,
			NextCursor: nextCursor,
			HasMore:    hasMore,
		}, nil

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", source)
	}
}

// PlatformOrder is the resolver for the platformOrder field.
func (r *queryResolver) PlatformOrder(ctx context.Context, source model.OrderSource, orderID uuid.UUID) (*model.PlatformOrder, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch source {
	case model.OrderSourceDeliveroo:
		adapter := r.DeliverooService.GetAdapter()

		order, err := adapter.GetOrderV2(ctx, orderID.String())
		if err != nil {
			return nil, fmt.Errorf("failed to fetch Deliveroo order: %w", err)
		}

		return convertDeliverooOrderToPlatformOrder(order, model.OrderSourceDeliveroo), nil

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", source)
	}
}

// ItemUnavailabilities is the resolver for the itemUnavailabilities field.
func (r *queryResolver) ItemUnavailabilities(ctx context.Context, source model.OrderSource, brandID uuid.UUID, siteID uuid.UUID) (*model.ItemUnavailabilityList, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch source {
	case model.OrderSourceDeliveroo:
		adapter := r.DeliverooService.GetAdapter()

		response, err := adapter.GetItemUnavailabilitiesV2(ctx, brandID.String(), siteID.String())
		if err != nil {
			return nil, fmt.Errorf("failed to fetch item unavailabilities: %w", err)
		}

		return convertDeliverooUnavailabilityList(response), nil

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", source)
	}
}

// PlusMappings is the resolver for the plusMappings field.
func (r *queryResolver) PlusMappings(ctx context.Context, source model.OrderSource, brandID uuid.UUID, menuID uuid.UUID) ([]*model.PLUMapping, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch source {
	case model.OrderSourceDeliveroo:
		// Note: Deliveroo doesn't have a direct API to GET PLU mappings
		// This would need to be stored locally or fetched from menu data
		return nil, fmt.Errorf("PLU mappings retrieval not yet implemented")

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", source)
	}
}

// PreviewSyncMenuPlatform is the resolver for the previewSyncMenuPlatform field.
func (r *queryResolver) PreviewSyncMenuPlatform(ctx context.Context, source model.OrderSource, brandID uuid.UUID, menuID uuid.UUID) (*model.MenuSyncPreview, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch source {
	case model.OrderSourceDeliveroo:
		// Fetch categories and products from the database
		categories, err := r.ProductService.GetCategories(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to fetch categories: %w", err)
		}

		products, err := r.ProductService.GetProducts(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to fetch products: %w", err)
		}

		// Get preview from the Deliveroo service
		preview, err := r.DeliverooService.PreviewMenuSync(ctx, categories, products)
		if err != nil {
			return nil, fmt.Errorf("failed to preview menu sync: %w", err)
		}

		// Convert service types to GraphQL model types
		return convertServicePreviewToGraphQL(preview), nil

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", source)
	}
}

// PlatformOrderUpdates is the resolver for the platformOrderUpdates field.
func (r *subscriptionResolver) PlatformOrderUpdates(ctx context.Context, source model.OrderSource, restaurantID uuid.UUID) (<-chan *model.PlatformOrder, error) {
	// Create a channel for order updates
	ch := make(chan *model.PlatformOrder, 1)

	// Subscribe to new platform orders for this source
	newOrdersTopic := fmt.Sprintf("platformOrder:new:%s", source)

	go func() {
		defer close(ch)

		// Subscribe to new orders from the broker
		eventCh := r.Broker.Subscribe(newOrdersTopic)
		defer r.Broker.Unsubscribe(newOrdersTopic, eventCh)

		for {
			select {
			case <-ctx.Done():
				return
			case event := <-eventCh:
				// Convert domain.Order to PlatformOrder
				if order, ok := event.(*domain.Order); ok {
					if !order.PlatformData.IsNull() {
						var deliverooOrder deliveroo.Order
						if err := order.PlatformData.Unmarshal(&deliverooOrder); err == nil {
							platformOrder := convertDeliverooOrderToPlatformOrder(&deliverooOrder, source)
							select {
							case ch <- platformOrder:
							case <-ctx.Done():
								return
							}
						}
					}
				}
			}
		}
	}()

	return ch, nil
}

// PlatformRiderUpdates is the resolver for the platformRiderUpdates field.
func (r *subscriptionResolver) PlatformRiderUpdates(ctx context.Context, source model.OrderSource, restaurantID uuid.UUID) (<-chan *model.PlatformRiderUpdate, error) {
	// Create a channel for rider updates
	ch := make(chan *model.PlatformRiderUpdate, 1)

	// Subscribe to all rider updates (we'll filter by source in the handler)
	// Topic format: platformRider:update:{orderId}
	// Since we don't know order IDs in advance, we subscribe to a wildcard topic
	topic := "platformRider:update:*"

	go func() {
		defer close(ch)

		// Subscribe to events from the broker
		eventCh := r.Broker.Subscribe(topic)
		defer r.Broker.Unsubscribe(topic, eventCh)

		for {
			select {
			case <-ctx.Done():
				return
			case event := <-eventCh:
				// Event is a map[string]interface{} with orderId and riders
				if riderData, ok := event.(map[string]interface{}); ok {
					// Convert to PlatformRiderUpdate
					if riders, ok := riderData["riders"].([]deliveroo.RiderInfo); ok {
						// Convert riders to model riders
						var modelRiders []*model.PlatformRiderInfo
						for _, rider := range riders {
							modelRiders = append(modelRiders, convertDeliverooRiderToPlatformRider(&rider))
						}

						// Get order ID
						var orderID uuid.UUID
						if id, ok := riderData["orderId"].(uuid.UUID); ok {
							orderID = id
						}

						riderUpdate := &model.PlatformRiderUpdate{
							OrderID:     orderID,
							Riders:      modelRiders,
							StackedWith: []uuid.UUID{}, // Empty for now, would need to get from rider data
						}

						select {
						case ch <- riderUpdate:
						case <-ctx.Done():
							return
						}
					}
				}
			}
		}
	}()

	return ch, nil
}

// Mutation returns graphql1.MutationResolver implementation.
func (r *Resolver) Mutation() graphql1.MutationResolver { return &mutationResolver{r} }

// Subscription returns graphql1.SubscriptionResolver implementation.
func (r *Resolver) Subscription() graphql1.SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
