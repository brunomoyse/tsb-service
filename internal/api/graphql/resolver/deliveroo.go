package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"
	"time"
	graphql1 "tsb-service/internal/api/graphql"
	"tsb-service/internal/api/graphql/model"
	"tsb-service/services/deliveroo"

	"github.com/google/uuid"
)

// AcceptPlatformOrder is the resolver for the acceptPlatformOrder field.
func (r *mutationResolver) AcceptPlatformOrder(ctx context.Context, input model.AcceptOrderInput) (*model.PlatformOrder, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch input.Source {
	case model.OrderSourceDeliveroo:
		adapter := r.DeliverooService.GetAdapter()

		// Use UpdateOrder to accept the order
		acceptReq := deliveroo.UpdateOrderRequest{
			Status: deliveroo.OrderUpdateAccepted,
			Notes:  input.Notes,
		}

		if err := adapter.UpdateOrder(ctx, input.OrderID.String(), acceptReq); err != nil {
			return nil, fmt.Errorf("failed to accept Deliveroo order: %w", err)
		}

		// Fetch the updated order
		order, err := adapter.GetOrderV2(ctx, input.OrderID.String())
		if err != nil {
			return nil, fmt.Errorf("failed to fetch updated order: %w", err)
		}

		return convertDeliverooOrderToPlatformOrder(order, model.OrderSourceDeliveroo), nil

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", input.Source)
	}
}

// RejectPlatformOrder is the resolver for the rejectPlatformOrder field.
func (r *mutationResolver) RejectPlatformOrder(ctx context.Context, input model.RejectOrderInput) (*model.PlatformOrder, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch input.Source {
	case model.OrderSourceDeliveroo:
		adapter := r.DeliverooService.GetAdapter()

		// Convert reason string to RejectReason
		reason := deliveroo.RejectReason(input.Reason)

		// Use UpdateOrder to reject the order
		rejectReq := deliveroo.UpdateOrderRequest{
			Status:       deliveroo.OrderUpdateRejected,
			RejectReason: &reason,
			Notes:        input.Notes,
		}

		if err := adapter.UpdateOrder(ctx, input.OrderID.String(), rejectReq); err != nil {
			return nil, fmt.Errorf("failed to reject Deliveroo order: %w", err)
		}

		// Fetch the updated order
		order, err := adapter.GetOrderV2(ctx, input.OrderID.String())
		if err != nil {
			return nil, fmt.Errorf("failed to fetch updated order: %w", err)
		}

		return convertDeliverooOrderToPlatformOrder(order, model.OrderSourceDeliveroo), nil

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", input.Source)
	}
}

// UpdatePlatformOrderPrepStage is the resolver for the updatePlatformOrderPrepStage field.
func (r *mutationResolver) UpdatePlatformOrderPrepStage(ctx context.Context, input model.UpdatePrepStageInput) (*model.PlatformOrder, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch input.Source {
	case model.OrderSourceDeliveroo:
		adapter := r.DeliverooService.GetAdapter()

		prepStageReq := deliveroo.CreatePrepStageRequest{
			Stage:      convertGraphQLPrepStageToDeliveroo(input.Stage),
			OccurredAt: time.Now(),
			Delay:      input.Delay,
		}

		if err := adapter.CreatePrepStage(ctx, input.OrderID.String(), prepStageReq); err != nil {
			return nil, fmt.Errorf("failed to update prep stage: %w", err)
		}

		// Fetch updated order
		order, err := adapter.GetOrderV2(ctx, input.OrderID.String())
		if err != nil {
			return nil, fmt.Errorf("failed to fetch updated order: %w", err)
		}

		return convertDeliverooOrderToPlatformOrder(order, model.OrderSourceDeliveroo), nil

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", input.Source)
	}
}

// UpdateItemAvailabilities is the resolver for the updateItemAvailabilities field.
func (r *mutationResolver) UpdateItemAvailabilities(ctx context.Context, source model.OrderSource, brandID uuid.UUID, siteID uuid.UUID, items []*model.UpdateItemAvailabilityInput) (*model.ItemUnavailabilityList, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch source {
	case model.OrderSourceDeliveroo:
		adapter := r.DeliverooService.GetAdapter()

		unavailabilities := make([]deliveroo.ItemUnavailability, len(items))
		for i, item := range items {
			unavailabilities[i] = deliveroo.ItemUnavailability{
				ItemID: item.ItemID.String(),
				Status: convertGraphQLAvailabilityStatusToDeliveroo(item.Status),
			}
		}

		req := deliveroo.UpdateItemUnavailabilitiesRequest{
			ItemUnavailabilities: unavailabilities,
		}

		if err := adapter.UpdateItemUnavailabilitiesV2(ctx, brandID.String(), siteID.String(), req); err != nil {
			return nil, fmt.Errorf("failed to update item availabilities: %w", err)
		}

		// Fetch updated unavailabilities
		response, err := adapter.GetItemUnavailabilitiesV2(ctx, brandID.String(), siteID.String())
		if err != nil {
			return nil, fmt.Errorf("failed to fetch updated unavailabilities: %w", err)
		}

		return convertDeliverooUnavailabilityList(response), nil

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", source)
	}
}

// ReplaceAllUnavailabilities is the resolver for the replaceAllUnavailabilities field.
func (r *mutationResolver) ReplaceAllUnavailabilities(ctx context.Context, source model.OrderSource, brandID uuid.UUID, siteID uuid.UUID, input model.ReplaceAllUnavailabilitiesInput) (*model.ItemUnavailabilityList, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch source {
	case model.OrderSourceDeliveroo:
		adapter := r.DeliverooService.GetAdapter()

		unavailableIDs := make([]string, len(input.UnavailableIds))
		for i, id := range input.UnavailableIds {
			unavailableIDs[i] = id.String()
		}

		hiddenIDs := make([]string, len(input.HiddenIds))
		for i, id := range input.HiddenIds {
			hiddenIDs[i] = id.String()
		}

		req := deliveroo.ReplaceAllUnavailabilitiesRequest{
			UnavailableIDs: unavailableIDs,
			HiddenIDs:      hiddenIDs,
		}

		if err := adapter.ReplaceItemUnavailabilitiesV2(ctx, brandID.String(), siteID.String(), req); err != nil {
			return nil, fmt.Errorf("failed to replace unavailabilities: %w", err)
		}

		// Fetch updated unavailabilities
		response, err := adapter.GetItemUnavailabilitiesV2(ctx, brandID.String(), siteID.String())
		if err != nil {
			return nil, fmt.Errorf("failed to fetch updated unavailabilities: %w", err)
		}

		return convertDeliverooUnavailabilityList(response), nil

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", source)
	}
}

// MarkItemsAvailable is the resolver for the markItemsAvailable field.
func (r *mutationResolver) MarkItemsAvailable(ctx context.Context, source model.OrderSource, brandID uuid.UUID, siteID uuid.UUID, itemIds []uuid.UUID) (*model.ItemUnavailabilityList, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch source {
	case model.OrderSourceDeliveroo:
		adapter := r.DeliverooService.GetAdapter()

		unavailabilities := make([]deliveroo.ItemUnavailability, len(itemIds))
		for i, id := range itemIds {
			unavailabilities[i] = deliveroo.ItemUnavailability{
				ItemID: id.String(),
				Status: deliveroo.StatusAvailable,
			}
		}

		req := deliveroo.UpdateItemUnavailabilitiesRequest{
			ItemUnavailabilities: unavailabilities,
		}

		if err := adapter.UpdateItemUnavailabilitiesV2(ctx, brandID.String(), siteID.String(), req); err != nil {
			return nil, fmt.Errorf("failed to mark items available: %w", err)
		}

		// Fetch updated unavailabilities
		response, err := adapter.GetItemUnavailabilitiesV2(ctx, brandID.String(), siteID.String())
		if err != nil {
			return nil, fmt.Errorf("failed to fetch updated unavailabilities: %w", err)
		}

		return convertDeliverooUnavailabilityList(response), nil

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", source)
	}
}

// MarkItemsSoldOut is the resolver for the markItemsSoldOut field.
func (r *mutationResolver) MarkItemsSoldOut(ctx context.Context, source model.OrderSource, brandID uuid.UUID, siteID uuid.UUID, itemIds []uuid.UUID) (*model.ItemUnavailabilityList, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch source {
	case model.OrderSourceDeliveroo:
		adapter := r.DeliverooService.GetAdapter()

		unavailabilities := make([]deliveroo.ItemUnavailability, len(itemIds))
		for i, id := range itemIds {
			unavailabilities[i] = deliveroo.ItemUnavailability{
				ItemID: id.String(),
				Status: deliveroo.StatusUnavailable,
			}
		}

		req := deliveroo.UpdateItemUnavailabilitiesRequest{
			ItemUnavailabilities: unavailabilities,
		}

		if err := adapter.UpdateItemUnavailabilitiesV2(ctx, brandID.String(), siteID.String(), req); err != nil {
			return nil, fmt.Errorf("failed to mark items sold out: %w", err)
		}

		// Fetch updated unavailabilities
		response, err := adapter.GetItemUnavailabilitiesV2(ctx, brandID.String(), siteID.String())
		if err != nil {
			return nil, fmt.Errorf("failed to fetch updated unavailabilities: %w", err)
		}

		return convertDeliverooUnavailabilityList(response), nil

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", source)
	}
}

// UpdatePLUs is the resolver for the updatePLUs field.
func (r *mutationResolver) UpdatePLUs(ctx context.Context, source model.OrderSource, brandID uuid.UUID, menuID uuid.UUID, input model.UpdatePLUsInput) (bool, error) {
	if r.DeliverooService == nil {
		return false, fmt.Errorf("deliveroo service not configured")
	}

	switch source {
	case model.OrderSourceDeliveroo:
		adapter := r.DeliverooService.GetAdapter()

		mappings := make(deliveroo.UpdatePLUsRequest, len(input.Mappings))
		for i, mapping := range input.Mappings {
			mappings[i] = deliveroo.PLUMapping{
				ItemID: mapping.ItemID.String(),
				PLU:    mapping.Plu,
			}
		}

		if err := adapter.UpdatePLUs(ctx, brandID.String(), menuID.String(), mappings); err != nil {
			return false, fmt.Errorf("failed to update PLUs: %w", err)
		}

		return true, nil

	case model.OrderSourceUber:
		return false, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return false, fmt.Errorf("invalid source for platform order: %s", source)
	}
}

// SyncMenuToPlatform is the resolver for the syncMenuToPlatform field.
func (r *mutationResolver) SyncMenuToPlatform(ctx context.Context, source model.OrderSource, brandID uuid.UUID, menuID uuid.UUID) (bool, error) {
	if r.DeliverooService == nil {
		return false, fmt.Errorf("deliveroo service not configured")
	}

	switch source {
	case model.OrderSourceDeliveroo:
		// Fetch categories and products from the database
		categories, err := r.ProductService.GetCategories(ctx)
		if err != nil {
			return false, fmt.Errorf("failed to fetch categories: %w", err)
		}

		products, err := r.ProductService.GetProducts(ctx)
		if err != nil {
			return false, fmt.Errorf("failed to fetch products: %w", err)
		}

		// Sync menu using the Deliveroo service
		if err := r.DeliverooService.SyncMenu(ctx, categories, products); err != nil {
			return false, fmt.Errorf("failed to sync menu to Deliveroo: %w", err)
		}

		return true, nil

	case model.OrderSourceUber:
		return false, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return false, fmt.Errorf("invalid source for platform order: %s", source)
	}
}

// PlatformOrders is the resolver for the platformOrders field.
func (r *queryResolver) PlatformOrders(ctx context.Context, source model.OrderSource, brandID *uuid.UUID, restaurantID *uuid.UUID, filter *model.PlatformOrderFilter) (*model.PlatformOrdersConnection, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch source {
	case model.OrderSourceDeliveroo:
		adapter := r.DeliverooService.GetAdapter()

		req := deliveroo.GetOrdersV2Request{}
		if filter != nil {
			if filter.StartDate != nil {
				req.StartDate = filter.StartDate
			}
			if filter.EndDate != nil {
				req.EndDate = filter.EndDate
			}
			if filter.LiveOrdersOnly != nil {
				req.LiveOrders = *filter.LiveOrdersOnly
			}
			if filter.Cursor != nil {
				req.Cursor = filter.Cursor
			}
		}

		if brandID == nil || restaurantID == nil {
			return nil, fmt.Errorf("brandID and restaurantID are required for Deliveroo orders")
		}

		response, err := adapter.GetOrdersV2(ctx, brandID.String(), restaurantID.String(), req)
		if err != nil {
			return nil, fmt.Errorf("failed to fetch Deliveroo orders: %w", err)
		}

		orders := make([]*model.PlatformOrder, len(response.Orders))
		for i, order := range response.Orders {
			orders[i] = convertDeliverooOrderToPlatformOrder(&order, model.OrderSourceDeliveroo)
		}

		hasMore := response.Next != nil
		var nextCursor *string
		if response.Next != nil {
			nextCursor = response.Next
		}

		return &model.PlatformOrdersConnection{
			Orders:     orders,
			NextCursor: nextCursor,
			HasMore:    hasMore,
		}, nil

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", source)
	}
}

// PlatformOrder is the resolver for the platformOrder field.
func (r *queryResolver) PlatformOrder(ctx context.Context, source model.OrderSource, orderID uuid.UUID) (*model.PlatformOrder, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch source {
	case model.OrderSourceDeliveroo:
		adapter := r.DeliverooService.GetAdapter()

		order, err := adapter.GetOrderV2(ctx, orderID.String())
		if err != nil {
			return nil, fmt.Errorf("failed to fetch Deliveroo order: %w", err)
		}

		return convertDeliverooOrderToPlatformOrder(order, model.OrderSourceDeliveroo), nil

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", source)
	}
}

// ItemUnavailabilities is the resolver for the itemUnavailabilities field.
func (r *queryResolver) ItemUnavailabilities(ctx context.Context, source model.OrderSource, brandID uuid.UUID, siteID uuid.UUID) (*model.ItemUnavailabilityList, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch source {
	case model.OrderSourceDeliveroo:
		adapter := r.DeliverooService.GetAdapter()

		response, err := adapter.GetItemUnavailabilitiesV2(ctx, brandID.String(), siteID.String())
		if err != nil {
			return nil, fmt.Errorf("failed to fetch item unavailabilities: %w", err)
		}

		return convertDeliverooUnavailabilityList(response), nil

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", source)
	}
}

// PlusMappings is the resolver for the plusMappings field.
func (r *queryResolver) PlusMappings(ctx context.Context, source model.OrderSource, brandID uuid.UUID, menuID uuid.UUID) ([]*model.PLUMapping, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch source {
	case model.OrderSourceDeliveroo:
		// Note: Deliveroo doesn't have a direct API to GET PLU mappings
		// This would need to be stored locally or fetched from menu data
		return nil, fmt.Errorf("PLU mappings retrieval not yet implemented")

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", source)
	}
}

// PreviewSyncMenuPlatform is the resolver for the previewSyncMenuPlatform field.
func (r *queryResolver) PreviewSyncMenuPlatform(ctx context.Context, source model.OrderSource, brandID uuid.UUID, menuID uuid.UUID) (*model.MenuSyncPreview, error) {
	if r.DeliverooService == nil {
		return nil, fmt.Errorf("deliveroo service not configured")
	}

	switch source {
	case model.OrderSourceDeliveroo:
		// Fetch categories and products from the database
		categories, err := r.ProductService.GetCategories(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to fetch categories: %w", err)
		}

		products, err := r.ProductService.GetProducts(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to fetch products: %w", err)
		}

		// Get preview from the Deliveroo service
		preview, err := r.DeliverooService.PreviewMenuSync(ctx, categories, products)
		if err != nil {
			return nil, fmt.Errorf("failed to preview menu sync: %w", err)
		}

		// Convert service types to GraphQL model types
		return convertServicePreviewToGraphQL(preview), nil

	case model.OrderSourceUber:
		return nil, fmt.Errorf("Uber Eats integration not yet implemented")

	default:
		return nil, fmt.Errorf("invalid source for platform order: %s", source)
	}
}

// PlatformOrderUpdates is the resolver for the platformOrderUpdates field.
func (r *subscriptionResolver) PlatformOrderUpdates(ctx context.Context, source model.OrderSource, restaurantID uuid.UUID) (<-chan *model.PlatformOrder, error) {
	// Create a channel for order updates
	ch := make(chan *model.PlatformOrder, 1)

	// Subscribe to platform order events
	topic := fmt.Sprintf("platform_order_updates:%s:%s", source, restaurantID)

	go func() {
		defer close(ch)

		// Subscribe to events from the broker
		eventCh := r.Broker.Subscribe(topic)
		defer r.Broker.Unsubscribe(topic, eventCh)

		for {
			select {
			case <-ctx.Done():
				return
			case event := <-eventCh:
				if platformOrder, ok := event.(*model.PlatformOrder); ok {
					select {
					case ch <- platformOrder:
					case <-ctx.Done():
						return
					}
				}
			}
		}
	}()

	return ch, nil
}

// PlatformRiderUpdates is the resolver for the platformRiderUpdates field.
func (r *subscriptionResolver) PlatformRiderUpdates(ctx context.Context, source model.OrderSource, restaurantID uuid.UUID) (<-chan *model.PlatformRiderUpdate, error) {
	// Create a channel for rider updates
	ch := make(chan *model.PlatformRiderUpdate, 1)

	// Subscribe to platform rider events
	topic := fmt.Sprintf("platform_rider_updates:%s:%s", source, restaurantID)

	go func() {
		defer close(ch)

		// Subscribe to events from the broker
		eventCh := r.Broker.Subscribe(topic)
		defer r.Broker.Unsubscribe(topic, eventCh)

		for {
			select {
			case <-ctx.Done():
				return
			case event := <-eventCh:
				if riderUpdate, ok := event.(*model.PlatformRiderUpdate); ok {
					select {
					case ch <- riderUpdate:
					case <-ctx.Done():
						return
					}
				}
			}
		}
	}()

	return ch, nil
}

// Mutation returns graphql1.MutationResolver implementation.
func (r *Resolver) Mutation() graphql1.MutationResolver { return &mutationResolver{r} }

// Subscription returns graphql1.SubscriptionResolver implementation.
func (r *Resolver) Subscription() graphql1.SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
